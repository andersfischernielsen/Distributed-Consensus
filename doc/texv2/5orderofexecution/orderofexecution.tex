% !TeX root = ../DistributedConsensus.tex
% !TeX spellcheck = en_GB
\chapter{Reducing Histories to Orders of Execution}\label{chap:order-of-execution}
	In this chapter, it is examined how it is possible to find an order of execution from a valid global history and it is shown that consensus can be reached on the found order of execution with an election.

\section{Order of Execution}
	A valid global history represents every action that has occurred on all the events of the workflow.
	It is desired to find an order of execution with excess information in the history removed without losing information regarding the order of the executions. To do this, we need to represent an execution as a single entity and furthermore find the minimum equivalent graph of the resulting order.
	
	\subsection{Single Entity Representing an Execution}
	In order to find a single representation of an execution, one approach could be to examine if a single action of an execution could describe all the relations to all the other executions. Doing this involves filtering all actions not chosen to be the representative of the execution, and since filtering nodes also removes their edges, happen before relations between executions would be lost. Therefore it is necessary to add a direct edge between representatives if there is already a path from one to the other in the history. Since the history is represented as a directed acyclic graph, the transitive closure of the graph provides the desired relations. Having found the transitive closure of the history, actions that are not the representative for an execution are removed from the graph along with their edge.
	
	Since every execution has actions of types \textit{Execute start} and \textit{Execute finish}, choosing one of these as the representative seems like a sensible choice. For any execution in a history, an action of type \textit{Execute start} always has a path to an action of type \textit{Execute finish}. Therefore the transitive property of directed acyclic graphs, states that in an execution the reachability of an action of type \textit{Execute start} is a superset of the reachability of the action of type \textit{Execute finish}, and therefore it contains more information about happens before relations. To conclude, actions of type \textit{Execute start} are the most sensible choice of these two types.
	
	A situation where actions of type \textit{Execute start} is chosen as representatives is shown in \autoref{fig:problem:trans}. What becomes apparent in this figure, is that the first execution of event $A$ must happen before the first execution of event $B$. This is because two events that have a happen before relation must have any kind of relation in the workflow. If the events have a relation in the workflow, then they must execute serially equivalent. This ensures that an execution of one of the events must happen either before, or after an execution of the other. Therefore another approach must be taken.
	
	\newpar In \cite{sedgewick2011algorithms}, Sedgewick et. al. describes an implementation of transitive closure, which has a time complexity of $\mathcal{O}(V * (V + E))$ where V is the number of nodes and E is the number of edges in the graph.
	
	\begin{figure}
		\centering
		\includegraphics[width=\textwidth]{5orderofexecution/images/trans.pdf}
		\caption{The result of finding the transitive closure on from the actions of an event. Note that the topmost executions happen concurrently. So do the two lower executions.}
		\label{fig:problem:trans}
	\end{figure}
	
	\subsection{Collapsing}
	As described above, transitive closures are not an ideal way of representing an execution as a single entity and therefore collapsing is introduced.
	
	\newpar In \autoref{def:execution} an execution is defined to be all the actions representing the effects of the execution, as well as two actions with types \textit{Execute start} and \textit{Execute finish}. Even though incoming actions are stored on other events than the ones performing the executions, these actions are still initiated by the executing event and are therefore seen as being part of the execution. Since an event is only affected by the effects of other events or itself executing, any action is always part of \textit{some} execution of \textit{some} event, and therefore no action can happen outside an execution.

	\newpar In a global history, given an action of type \textit{Execute start}, the set of actions representing a single execution is found by taking each consecutive action with the same event ID until an action of type \textit{Execute finish} is found. Furthermore the incoming actions corresponding to the outgoing actions already found in the execution are added to the set.
	
	\newpar In \autoref{inv:historyinvariant} it is said that if a single action in one execution happens before another action in another execution, then no action from the second execution can happen before an action in the first. In other words this means, if there exists an action in execution $A$, that happens before an action in execution $B$, then $A$ happens before $B$, and $B$ cannot happen before $A$. Note that this does not mean that all actions in $A$ happens before all actions in $B$, which means some of the actions are in fact concurrent. This creates the need for an argument that $A$ \textit{does} happen before $B$ despite that some actions are concurrent.
	
	\newpar As stated in the previous section, because of serial equivalence, two events, where one has a relation to the other, can only execute in a way such that the result is the same as if one had executed before the other. Therefore any happens before relation any action in an execution has with any action outside of that execution actually applies to all actions in the execution. When this is the case, every action inside an execution is equal in terms of happens-before relations and therefore we can \textit{collapse} the execution into one single entity.
	
	\newpar An example of collapsing actions into executions is shown in \autoref{fig:orderofexecution:collapse}. This is the same example as used when describing transitive closure. Contrary to \autoref{fig:problem:trans}, the first execution of $A$ happens before the first execution of $B$.
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=\textwidth]{5orderofexecution/images/collapse.pdf}
		\caption{The result of finding an execution using \textit{Collapse}. Note that some executions that previously were concurrent (\autoref{fig:problem:trans}) are now ordered.}
		\label{fig:orderofexecution:collapse}
	\end{figure}
	
	\newpar The collapsing algorithm can be be seen in \autoref{alg:collapse}. The algorithm gathers all actions of an execution and, after the single entity execution is created, creates all happens-before relations. In order to do so, it uses a few helper functions. \texttt{GetEdgesToOtherExecutions} together with \texttt{MapOldEdgesToNewIDs} represent the translation of edges of actions in one execution to actions in another execution, to edges from execution entity to execution entity.
	
	\begin{algorithm}[H]
		\begin{algorithmic}
			\Function{Collapse}{history} \textbf{returns} an order of execution \State
			actionMapper $\leftarrow$ \Call{EmptyMap}{ }
			\State executeStartActions $\leftarrow$ \Call{FilterByType}{ExecuteStart, history}
			\State
			\ForAll{action \textbf{in} executeStartActions}
				\Comment Loop 1
				\State execution $\leftarrow$ \Call{FindSingleExecution}{action}
				\State uniqueId $\leftarrow$ \Call{GenerateUniqueId}{ }
				\ForAll{executionAction \textbf{in} execution}\State
					actionMapper $\leftarrow$ \Call{Add}{action.Id, uniqueId, actionMapper} 
				\EndFor
			\EndFor
			\State
			\State orderOfExecution $\leftarrow$ \Call{EmptyGraph}{ }
			\State
			\ForAll{oldActionID, newActionID \textbf{in} actionMapper}
				\Comment Loop 2
				\State oldEdges $\leftarrow$ \Call{GetEdgesToOtherExecutions}{oldActionId, history}
				\State edges $\leftarrow$ \Call{MapOldEdgesToNewIDs}{oldEdges, actionMapper}
				\State newAction $\leftarrow$ \Call{CreateAction}{newActionId, edges}
			\State
			orderOfExecution $\leftarrow$ \Call{AddNode}{newAction, orderOfExecution} \State\Comment{This requires \Call{AddNode}{} to merge edge sets when existing nodes are added}
			\EndFor\State
			\Return orderOfExecution
			\EndFunction
		\end{algorithmic}
		\caption{Collapse algorithm}
		\label{alg:collapse}
	\end{algorithm}
	
	\noindent One of the properties the collapsed order of execution has, is that, for two executions to be concurrent the executing events must be independent, as described in \cite{debois2015concurrency}, however, not all independent\- events create concurrent executions.
	
	All non-independent events cannot execute concurrently, and to demonstrate this, we will show that if any of the properties of independent events are not present between a pair of events, therefore making them non-independent, then collapse will order the executions.
	
	\begin{enumerate}
		\item \textit{No event included by $E$ is excluded by $F$ and vice versa}: This property is violated if $E$ includes an event, $G$ that $F$ excludes. The incoming actions on $G$ will allow collapse to order the executions of $E$ and $F$.
		\item \textit{$E$ requires a response from some $G$ iff $F$ does}: This property is violated if $E$ has a response relation to $F$, but $F$ does not have a response relation to itself. In this case, an execution of $E$ results in incoming actions on $F$. Any execution of $F$ is always before or after these incoming actions.
		\item \textit{Neither event is a condition for the other}: This property is violated if $E$ is a condition for $F$. In this case the incoming actions from the execution of $F$ on $E$, enables the ordering of executions of the events.
		\item \textit{Neither event includes or excludes the other}: This property is violated if $E$ includes $F$. In this case the incoming actions from the execution of $E$ on $F$, enables the ordering of executions of the events.
		\item \textit{Neither event includes or excludes a condition of the other}: This property is violated if $E$ excludes $G$ which is a condition of $F$. Recall that conditions in the implementation are checked by the executing event. This means that any execution of $F$ will result in incoming actions on $G$. Also the execution of $E$ will result in incoming actions on $G$. Therefore the incoming actions on $G$ will allow collapse to order the executions of $E$ and $F$.
	\end{enumerate}\todo[inline]{Insert independent in background of dcr graphs}
	
	To argue that the collapse algorithm correctly describes the relations between executions \autoref{inv:historyinvariant} is examined. The invariant states that if there exist any action in execution $A$ with a relation to execution $B$, then it must not be true the other way around. Therefore for collapse to be correct every single execution entity must have the abide to the invariant. 
	
	Since the set of relations the entity representing an execution has to other executions is the union of the sets of all the relations the actions of the execution had to other executions, then the set cannot contain relations which violates the invariant, because then the invariant would already be violated before collapsing. If the invariant is violated in the union set, then there must have been an action in an execution $A$ that happens before an action in an execution $B$ and an action in $B$ that happens before an action in $A$ in the original collection of sets representing the executions.
	
	\newpar The algorithm runs in a time complexity of $\mathcal{O}(N+E)$ where $N$ is the number of actions and $E$ is the number of edges in the history. This is due to \texttt{FindSingleExecution} and \texttt{executeStartActions} are inversely proportional and together constitutes the amount of actions in the graph. Therefore the overall complexity of \texttt{loop 1} is linear to the amount of actions. \texttt{Loop 2} iterates over every action in the history, furthermore every edge in the history is iterated over since they are retrieved for every action with \texttt{GetEdgesToOTherExecutions}. \texttt{MapOldEdgesToNewIds}, \texttt{CreateAction} runs in constant time and \texttt{AddNode} runs linear time to the amount of edges between executions, then the first part of the second loop is the dominant factor. Therefore the second loop run in $\mathcal{O}(N+E)$, and is then the most dominant factor of the entire algorithm.
	
	\subsection{Transitive Reduction}
	Redundant edges might still exist in between executions after collapsing a history. An edge is redundant in cases where there exists a non-direct path from an execution to another execution, but there also exists a direct edge between the two executions. In this case the direct edge is redundant and can be removed, since it does not contribute extra information in regards to the ordering of the executions, as it only explicitly expresses what is implicitly available. Removing the direct edge will not affect the ordering or reachability of the order of execution, but rather simplify it.
	
	\newpar Figure \ref{fig:orderofexecution:collapsing} illustrates a case where a redundant edge exists between executions of event $B$ and $A$, since there is a path from the execution of event $B$ to the execution of $A$ through the execution of event $C$. Recall that the order of execution is represented as a directed acyclic graph and that it is possible to find a minimal equivalent graph for such a graph.
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=\textwidth]{5orderofexecution/images/transitive-example-collapse.pdf}
		\caption{The result of collapsing actions in the histories of three events.}
		\label{fig:orderofexecution:collapsing}
	\end{figure}
	
	\newpar In directed acyclic graphs the transitive reduction produces the minimal equivalent graph. A naive algorithm for finding the transitive reduction on an order of execution is shown in \autoref{alg:orderofexecution:reduction}.
	
	\begin{algorithm}[H]
		\begin{algorithmic}
			\Function{Transitive-Reduction}{$orderOfExecution$}
				\ForAll{$execution1$ \textbf{in} $orderOfExecution$}
				\Comment Loop 1
					\ForAll{$execution2$ \textbf{in} $orderOfExecution$}
					\Comment Loop 2
						\If{\Call{PathExists}{$execution1$, $execution2$, $orderOfExecution$}}
							\ForAll{$execution3$ \textbf{in} $execution2.edges$}
							\Comment Loop 3
								\If{\Call{EdgeExists}{$execution1$, $execution3$}}
									\State $orderOfExecution$ $\leftarrow$ \State \hspace{2em}\Call{RemoveEdge} {$execution1$, $execution3$, $orderOfExecution$}
								\EndIf
							\EndFor
						\EndIf
					\EndFor
				\EndFor
			\State
			\Return $orderOfExecution$
			\EndFunction
		\end{algorithmic}
		\caption{Transitive Reduction Algorithm}
		\label{alg:orderofexecution:reduction}
	\end{algorithm}
	
	\newpar The shown algorithm for transitive reduction has a time complexity of $\mathcal{O}(n^2(n+e))$ where $n$ is the number of executions and $e$ is the number of happens-before relations between executions. Since \texttt{EdgeExists} and \texttt{RemoveEdge} run in constant time, \texttt{loop 3} has a time complexity of $\mathcal{O}(E)$ because in worst case \texttt{loop 2} iterates over all executions in the graph and \texttt{execution2.edges} represents all edges in the graph. \texttt{PathExists} has a time complexity of $\mathcal{O}(N+E)$ because each node is visited over each edge. Therefore \texttt{PathExists} becomes the dominant factor of the second loop. \texttt{Loop 1} and \text{Loop 2} has a time complexity of $\mathcal{O}(N^2)$ and therefore the combined time complexity of the entire algorithm is $\mathcal{O}(n^2(n+e))$.
	
	\begin{figure}[H]
		\centering
		\includegraphics[height=0.35\textheight]{5orderofexecution/images/reduce-before-after.pdf}
		\caption{The result of reducing an order of execution with redundant edges.}
		\label{fig:orderofexecution:reduce-before-after}
	\end{figure}

% Synes ikke det hører til her	
%	\newpar These algorithms do not provide a way to ensure that malicious nodes cannot tamper with the history. As in the case where one event represented the workflow, there is no way of making sure that the event creating the history will not tamper with the history. It would be possible to pinpoint which neighbouring events are malicious if enough of the neighbours have relations to each other. 


	\section{Election} 
	As we have now found an order of execution where (potentially) malicious events have been identified, we want to know if the remaining events can agree upon the rest of order of execution.
	
	\newpar As stated in the problem definition, it is desired to reach consensus on the resulting order of execution, but since no process in the system knows the entire state of a workflow, it is not possible for the events to suggest an order of execution without completing steps alike with the ones described in this report.
	
	\newpar Because we have chosen to let the client know all events in order to retrieve their histories, it is also easy for us to send the resulting order of execution back to them, in order to find out whether or not they can agree to this order.
	
	\newpar When any event receives this order of execution, it can look at its own history and at the received order. The local history can contain executions with outgoing actions between execute start and execute finish actions. Furthermore ingoing relations can be identified as executions of other events from the following rules:
	
	\begin{itemize}
		\item Each counterpart present in actions with ingoing action types must have executed at least once, in order to contact the local event.
		\item If two actions with the same ingoing action type and counterpart are present after each other, this denotes two separate executions of the counterpart event, because each executing event only contacts another event once per relation when executing.
	\end{itemize}
	
	%\newpar Furthermore if an event has sent multiple ingoing requests as part of a single execution, then each of the relations that these actions represent must be present every time that execution has happened.
	%Ovenstående er udkommenteret fordi det relaterer mere til validation end election.
	
	\newpar	Given these rules, the local history can be turned into a "local order of execution".
	\figuretodo{Tilføj figur der viser hvordan en lokal historik kan omdannes til en order of execution der kan bruges til afstemning.}
	
	\newpar Now that the event has created a local order of execution, this order can be used to decide whether or not the event can agree on the global order of execution. If there exists a path from one execution to another in the local order of execution, there must also exist a path between these executions in the global order of execution for the event to agree. Because the local history is totally ordered, the local order of execution must also be totally ordered.\todo[inline]{proof?}
	
	With this property the event can find the local order of execution in the global order. \todo[inline]{The following algorithm assumes that an execution can be found across local and global orders of execution.}Algorithm \ref{alg:vote} outlines how this can be done.
	
	\begin{algorithm}
		\begin{algorithmic}
			\Function{Vote}{localHistory, globalOrderOfExecution}
				\State\hspace{2em}\textbf{returns} \texttt{True} if the paths between executions in the local history are present in the
				\State\hspace{6em}global history. \texttt{False} otherwise.
				\State localOrderOfExecution $\leftarrow$ \Call{MakeLocalOrderOfExecution}{localHistory}
				\State localExecution $\leftarrow$ execution in localHistory with lowest local timestamp
				\While{\Call{IsNotNull}{currentLocalExecution}}
					\If{\Call{IsEmpty}{currentLocalExecution.Edges}}
						\State \Return \texttt{True}
					\EndIf
					\State globalExecution $\leftarrow$ find localExecution in globalOrderOfExecution
					\State nextGlobalExecution $\leftarrow$ find next local execution in globalOrderOfExecution
					\If{\Call{HasPath}{globalExecution, nextGlobalExecution, globalOrderOfExecution}}
						\State\Return \texttt{False}
					\EndIf
					
					\State localExecution $\leftarrow$ \Call{SingleOrNull}{localExecution.Edges}
				\EndWhile
			\EndFunction
		\end{algorithmic}
		\caption{The \textit{\textbf{Vote}} algorithm}
		\label{alg:vote}
	\end{algorithm}
	
	If the history is correct, and the nodes are correct, then the nodes will vote in favour of the history.
	
	It is possible to decide a threshold for the ratio between the number of good nodes and the number of malicious nodes. If the result of the election is better than the threshold, then distributed consensus between the nodes exists for the history. In distributed systems this threshold is normally set to the majority of the participating nodes, which means at least one more than half the amount of nodes.\todo[inline]{Find a source.}
	
	\newpar Election is not an actual vote on the result of the resulting order of execution. Election is instead a confirmation that the algorithm has produced the correct result.
	
	\todo[inline]{Tilføj correctness proof/paragraph. "There should be a theorem or something clearly stating that this algorithm solves the original problem." WIND: i dont know if this was it but i tried PIL NED}
	
	If the algorithm has found the correct solution then correctly functioning events must be decide to accept the result. By proof of contradiction if the correctly functioning events do not vote for the history then that implies that happens before relations are missing from the global history, which would then imply that the proposed global order was incorrect and therefore that the proposer is malicious.
	
	This algorithm solves the initial problem which was to achieve distributed consensus on the order of execution. It does so because each individual event can accept a proposed value by the commander, and if the commander is correct then all the events will have decided the same value, and distributed consensus is hereby achieved.
	
	
	\figuretodo{Tilføj figur: Kan vi på nogen måde vise resultatet af election? FISK: Tror det bliver lidt svært. }