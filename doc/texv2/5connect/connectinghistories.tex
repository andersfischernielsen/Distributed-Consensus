% !TeX root = DistributedConsensus.tex
% !TeX spellcheck = en_GB
\chapter{Connecting Histories} % Måske bedre navn. Dette er lidt for Nokia.
\label{chap:connecting-histories}
	This chapter defines the merging of logs across multiple events into one consistent history. Furthermore it describes how it is possible to simplify a graph of logs into an order of execution.
	
	\begin{definition}
		A \textit{\textbf{Consistent History}} is a (possibly combined) history, A, which for every history that was part of the creation of history A, if there is a path from one action to another, this path must also exist in history A. Furthermore related actions must be combined to create the most restricted order of execution possible.
	\end{definition} % Todo: Is this consise enough?
	% Happens before, Transitive Closure, Transitive Reduction, Collapsing, Filtering, No cycles in history
	\noindent We now expand the problem domain by allowing multiple events in the DCR graph distributed on multiple computers. We define:
	\begin{definition}
		A \textit{\textbf{neighbouring event}} of an event A is an event which event A has a relation to. \todo{Har vi defineret relation?}
	\end{definition}
	\noindent In this section all the events in the workflow are neighbours of the event responsible for generating the history in the DCR graph.
	
	\section{Merging histories} 
	In order to build a history for the events in the workflow, the actions of the events must be connected somehow in order to (at least) partially order them and thereby determine the global history. Due to the nature of actions being distributed, it is not possible to ensure a total order of actions. For example if action A on event A knows that it has happened before action B on event B, and action C on event C, but there is no relation between event B and C, then we have no way of knowing if action B or C happened first. This case can be seen on \autoref{fig:connect:partialorder}.
	
	\begin{figure}
		\centering
		\import{5connect/images/}{partialorder.pdf_tex}
		\caption{The result of finding an order of execution when two events have no happens-before relations.}
		\label{fig:connect:partialorder}
	\end{figure}
	
	\subsection{Happens-before}
	The concept of happens-before relations helps determining what actions have happened before others across events.
	
	\todo{har vi ikke allerede defineret dette i teori samt representing a history? (jeg har tilføjet recall)}
	Recall that individual actions that have happened on an event will have happens-before relations between them, according to the rule that if $A$ and $B$ occur on the same process, then $A \rightarrow B$ if $A$ happened before $B$ on event $E$.
	Also recall that edges can be created between actions on two different events, if $A$ is registered as sent on event $a$ and is registered\todo{Er registered as nødvendigt her?} as received on event $b$.
	
	The concepts of transitivity, irreflexivity and antisymmetry also apply to happens-before relations. That is if $A \rightarrow B$ and $B \rightarrow C$, then $A \rightarrow C$ (transitivity), $A \not\rightarrow A$ (irreflexivity) and if $A \neq B$ and $A \rightarrow B$ then $B \not\rightarrow A$ (antisymmetry).
	
	\newpar As discussed in \autoref{chap:representing-a-history} an action can be seen from two perspectives: The perspective of the performer and the perspective of the receiver.
	Because the two actions represent sides of the same message exchange, we say that an initiation of this action happens before the action is logged on the receiving side. Therefore an edge can be created between the pairs of actions that correspond to each other. The types of actions that can correspond are defined in \autoref{def:happensbeforeaction}.
	
	\begin{definition}
		The following relations describe what action types happen before other action types.
			\begin{itemize}
				\item Includes $\rightarrow$ Included by
				\item Excludes $\rightarrow$ Excluded by
				\item Sets pending $\rightarrow$ Set pending by
				\item Checks condition $\rightarrow$ Checked condition by
				\item Locks $\rightarrow$ Locked by
				\item Unlocks $\rightarrow$ Unlocked by
			\end{itemize}
			\label{def:happensbeforeaction}
	\end{definition}
	
	\newpar Because multiple events can share actions, and also, the types of two actions are not enough to determine whether or not that pair of actions is each others complement. Therefore the actions are also matched by the ID of the counterpart, seen from each side. Because the same event can possibly be executed multiple times, and thereby create multiple pairs of corresponding actions, at least one of the actions must know the local time stamp of the other. In the implementation we have chosen that the performer logs the time stamp of its counterpart as part of its action. With this information pairs of actions can uniquely be identified, eliminating the possibility of creating inconsistent histories due to mispaired \todo{Jeg ved ikke om man kan bruge dette ord, men det bruges omkring DNA kæder hvis de mod\-stående nukleotider ikke passer sammen} data. Furthermore an action can only match with one other action following these rules. This limits the amount of outgoing (and incoming) edges for each action to 0 to 2 (remember that an action is also part of the local history of the event).
	
	Given this functionality provided by the happens before relations, an algorithm can be created to merge two histories together. First of all, every action of the history need to be added to a joined history. To connect actions, for each action of the graph the corresponding action is found by the rules described in the previous section. Whenever a match is found the edge is added from the performing action to the receiving action. With this algorithm a set of histories can then be merged together, two at a time, until one final combined history remains.
	
	\section{Simplifying}
	When a combined history has been produced, it represents all the actions that has happened in the workflow. This, however, is a history that contains more information than is necessary to show the order of execution. Finding the history with only executions is therefore desired.
	
	% Transitive closure
	%\newpar In order to remove unnecessary actions and preserve the order of execution, direct edges between executions in the history graph must be created based on the existing paths so that reachability between executions is preserved. The transitive closure of a graph has this property and therefore an algorithm finding this closure is needed.\footnote{\url{https://en.wikipedia.org/wiki/Transitive_closure}} Since reachability is preserved by only creating edges from an execution to the first execution encountered on every path from the execution, it is not required to find a complete transitive closure, as long as it is then done for every of the encountered executions. An example of this can be seen on %\autoref{fig:connect:3executionstrans}.
	
	%\begin{figure}
	%	\centering
	%	\def\svgwidth{0.42\columnwidth}
	%	\fontsize{6}{8}\selectfont
	%	\import{5connect/images/}{3executionswithtransitive.pdf_tex}
	%	\caption{3 executions before and after applying execution transitive closure.}
	%	\label{fig:connect:3executionstrans}
	%\end{figure}
	
	%\begin{algorithm}
	%	\begin{algorithmic}
	%	\Function{Execution Transitive-Closure}{history}
	%		\State startFromSet $\leftarrow$ actions with no incomming edges in history
	%		\ForAll{fromAction in startFromSet}
	%			\State neighbourActions $\leftarrow$ \Call{GetNeighboursOfNeighbours}{fromAction}
	%			\ForAll{neighbour in neighbourActions}
	%				\If {neighbour is execution}
	%					\State history $\leftarrow$ \Call{addEdge}{fromAction, neighbour, history}
	%					\State startFromSet $\leftarrow$ \Call{add}{neighbour, startFromSet}
	%				\Else
	%					\State neighbourActions $\leftarrow$ \Call{Union}{neighbour.neighbours, neighbourActions}
	%				\EndIf
	%			\EndFor
	%		\EndFor
	%		\State 
	%		\Return graph
	%	\EndFunction
	%	\end{algorithmic}
	%	\caption{Transitive Closure Algorithm}
	%\end{algorithm}
	

	% TODO: Collapsing
	\subsection{Collapsing}
	Although it is the receiver that saves the "by"-actions, these actions are still initiated by the performer, and is therefore part of the performers execution. By the use of this idea...\todo{Continue}
		
	When looking at the order of execution, it can be difficult to determine which action should be the canonical representation of the time of an execution. If \texttt{ExecuteFinish} is chosen, it can be difficult to tell which execution happened before the other, due to the fact that related actions happen before the \texttt{ExecuteFinish} action. 
	The same is true for the \texttt{ExecuteStart} action. It therefore needs to be decided what constitutes an entire execution, and to decide in what order these executions happen.
	
	\newpar It is necessary to research a way to \textit{collapse} an execution in order to overcome these problems. \textit{Collapsing} is to look at all of the actions between an \texttt{ExecuteStart} action and an \texttt{ExecuteFinish} action of an event and connect these events into a single entity, representing an entire execution. 
	
	The actions between start and finish might contain relations to other actions located in the local histories of other events. Since events are only affected by other events being executed, it is safe to collapse these actions into a single execution going out from the current event, due to this fact. Since an action is always caused by the execution of \textit{some} event, the property that no action has happened outside the execution of an event is also gained\todo{'Gained' er ikke det rigtige udtryk her.}. 
	
	An example of this separation of executions can be found in \autoref{fig:before-collapsing}.
	
	\begin{figure}
		\centering
		\def\svgwidth{0.42\columnwidth}
		\fontsize{6}{8}\selectfont
		\import{5connect/images/}{before_collapsing.pdf_tex}
		\caption{Separation of executions}
		\label{fig:before-collapsing}
	\end{figure}
	\todo{Måske skal denne figur laves ud fra GasWorkflow}
	
	\newpar When actions contained in an exectuion have been found, it is necessary to decide what should happen to the groupings. It is desired to keep all relations intact, and therefore all ingoing edges to the current event are pointed towards a new \textit{collapsed node}, and all outgoing edges are added to the same new node. This new \textit{collapsed node} then represents the entire execution. 
	
	In order not to create another type of action, the \texttt{ExecuteFinish} type was chosen to denote a collapsed execution. As it can be seen in \autoref{fig:after-collapsing} the collapsing of executions results in an order of execution.
	\todo{udvid (find bedre eksempel) med at særlige tilfælde kræver transitive reduction efter\-følgende}
	
	\begin{figure}
		\centering
		\def\svgwidth{0.22\columnwidth}
		\fontsize{6}{8}\selectfont
		\import{5connect/images/}{after_collapsing.pdf_tex}
		\caption{Executions after collapsing}
		\label{fig:after-collapsing}
	\end{figure}
	\todo{Måske skal denne figur laves ud fra GasWorkflow}
	
	The Collapse algorithm can be seen in \autoref{alg:collapse}.
	
	\begin{algorithm}
		\begin{algorithmic}
			\Function{Collapse}{graph}\State
				locals: CollapseMap: Mapping from old to newaction IDs.
				\State\hspace{28pt} Result: Graph, initially empty
				\State
				\State ExecuteStarts $\leftarrow$ \Call{Filter}{type = ExecuteStart, graph} \State
				Executions $\leftarrow$ \Call{Map.map}{FindSingleExecution, ExecuteStarts}
				\ForAll{executions in Executions}\State
					CollapseMap $\leftarrow$ \Call{CreateExecutionMap}{execution, newExecutionId, CollapseMap}
				\EndFor
				\ForAll{oldActionID, newActionID in CollapseMap}
					\State
					NewAction $\leftarrow$ Action with \State\hspace{28pt}ID = newActionID and \State\hspace{28pt}Edges = edges from oldActionID in graph mapped to new IDs\State
					Result $\leftarrow$ \Call{AddNode}{NewAction, Result} \State\Comment{This requires AddNode to merge edge sets when existing nodes are added}
				\EndFor
				
			\EndFunction
			\State
			\Function{FindSingleExecution}{startAction}
				\State locals: execution
				\While{startAction.Type $\neq$ ExecuteFinish} \State
					execution $\leftarrow$ \Call{AddRange}{startAction.Edges, execution}
				\EndWhile\State
				\Return execution
			\EndFunction
			\State
			\Function{CreateExecutionMap}{ActionSet, newActionId, accumulatorMap}
				\ForAll{actions in ActionSet}\State
					accumulatorMap $\leftarrow$ \Call{Add}{action.Id, newActionId, accumulatorMap}
				\EndFor \State
				\Return accumulatorMap
			\EndFunction
		\end{algorithmic}
		\caption{Collapse algorithm}
		\label{alg:collapse}
	\end{algorithm}
	
	\todo[inline]{The following paragraphs is about closures and filtering. Remove?}
	\newpar After finding the transitive closures between executions it is possible to filter actions depending on their type. If a history describing an order of execution is desired, then every action except for \texttt{Execution finish} must be removed from the history graph. 
	
	\subsection{Transitive Reduction}
	% TODO: Transitive reduction
	\newpar In the resulting history, redudant edges can still exist. In cases where there exists a path from an action to another action as well as a direct edge from the two, the direct edge is redundant and can be removed.	A subgraph of the history with the same reachability but with as few edges as possible, a minimum equivalent graph, is therefore desired. Finding this is possible by transitive reduction on the original graph, which then results in the minimum equivalent graph. Therefore, if there is a path from an edge $x$ to an edge $y$ in graph G, there must also be a path from $x$ to $y$ in the transitive reduction of $G$, and vice versa. 
	
	\begin{algorithm}
		\begin{algorithmic}
			\Function{Execution Transitive-Reduction}{history}
				\ForAll{action1 in history}
					\ForAll{action2 in history}
						\If{\Call{pathExists}{action1, action2, history}}
							\ForAll{action3 in history}
								\If{\Call{edgeExists}{action2, action3, history}}
									\If{\Call{edgeExists}{action1, action3, history}}
										\State history $\leftarrow$ \Call{removeEdge} {action1, action3, history}
									\EndIf
								\EndIf
							\EndFor
						\EndIf
					\EndFor
				\EndFor
			\State
			\Return history
			\EndFunction
		\end{algorithmic}
		\caption{Transitive Reduction Algorithm}
	\end{algorithm}
	
	\newpar The transitive reduction algorithm runs in $O(n^3)$ where n is the number of actions. This can be seen by the fact that the algorithm has a triple nested for-loop over all the actions in the history. This is based on the requirements that $pathExist$ runs in linear time and $edgeExist$ is constant. Realistically the graph will not be totally connected and therefore the innermost loop will not be executed for most of the actions.
	
	\newpar By combining these three steps, transitive closure, filtering and transitive reduction, we find the order of execution represented as a minimum equivalent graph of the entire history. 
	
	\newpar These algorithms do not provide a way to ensure that malicious nodes cannot falsify the history. Just like in the case where one event represented the workflow, we have no way of making sure that the event creating the history will not tamper with the history. It would be possible to pinpoint which neighbouring events are malicious if enough of the neighbours have relations to eachother. The following chapters go more into depth with why that is the case.
	