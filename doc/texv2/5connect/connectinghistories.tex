% !TeX root = DistributedConsensus.tex
\chapter{Connecting Histories} % MÃ¥ske bedre navn. Dette er lidt for Nokia.
\label{chap:connecting-histories}
	This chapter defines the merging of logs across multiple events into one consistent history. Furthermore it describes how it is possible to simplify a graph of logs into an order of execution.
	% Happens before, Transitive Closure, Transitive Reduction, Collapsing, Filtering, No cycles in history
	We now expand the problem domain by allowing multiple events in the DCR graph distributed on multiple computers. We define:
	\begin{definition}
		A \textit{\textbf{neighbouring event}} of an event A is an event which event A has a relation to.  
	\end{definition}
	\noindent All the events in the workflow are neighbours of the event responsible for generating the history in the DCR graph.
	
	\section{Merging histories} 
	In order to build a history for the events in the workflow, the actions of the events must be connected somehow in order to partially order them and thereby determine the global history. Due to the nature of actions being distributed, it is not possible to ensure a total order of actions. For example if action A on event A knows that it has happened before action B on event B, and action C on event C, but there is no relation between event B and C, then we have no way of knowing if action B or C happened first. This case can be seen on \autoref{fig:connect:partialorder}.
	
	\begin{figure}
		\centering
		\import{5connect/images/}{partialorder.pdf_tex}
		\caption{The result of finding an order of execution when two events have no happens-before relations.}
		\label{fig:connect:partialorder}
	\end{figure}
	
	%Happens-before
	\newpar The concept of happens-before relations helps determining what actions have happened before others across events. 
	
	The individual actions that have happened on an event will have happens-before relations between them, according to the rule that if $A$ and $B$ occur on the same process, then $A \rightarrow B$ if $A$ happened before $B$ on event $E$. 
	Futhermore edges can be created between actions on two different events, if $A$ is registered as sent on event $a$ and is registered as received on event $b$.
	
	The concepts of transitivity, irreflexivity and antisymmetry also apply to happens-before relations. That is if $A \rightarrow B$ and $B \rightarrow C$, then $A \rightarrow C$ (transitivity), $A \not\rightarrow A$ (irreflexivity) and if $A \neq B$ and $A \rightarrow B$ then $B \not\rightarrow A$ (antisymmetry).
	
	\newpar Using the representation of history detailed in \autoref{chap:representing-a-history} it is possible to create a graph of happens-before relations. To connect actions across events, the action ID and the counterpart action ID of the action is used, in addition to the type of the action. We define the relation between action types as:
	
	\begin{definition}
		The following relations describe what action types happen before other action types.
			\begin{itemize}
				\item Includes $\rightarrow$ Included by
				\item Excludes $\rightarrow$ Excluded by
				\item Sets pending $\rightarrow$ Set pending by
				\item Checks condition $\rightarrow$ Checked condition by
				\item Locks $\rightarrow$ Locked by
				\item Unlocks $\rightarrow$ Unlocked by
			\end{itemize}
	\end{definition}
	
	Given this functionality provided by the happens before relations, an algorithm can be created to merge two histories together. First of all, every actions of the history need to be added to a joined history. To connect actions, for each action of the graph the corrosponding action is found due to the rules described in the previous section. Then an edge is created from the first action to the second. Every action has at most one corresponding action due to the fact that an action ID is unique in the workflow and it is therefore possible to match the counterpart ID with the exact action it corresponds to. With this algorithm a set of histories can then be merged together two at the time, until one final combined history remains.
	
	\section{Simplifying}
	When a combined history has been produced, it represents all the actions that has happened in the workflow. This however is a history that contains more information than is necessary to show the order of execution. Finding the history with only executions is therefore desired.
	
	% Transitive closure
	\newpar In order to remove unnecessary actions and preserve the order of execution, direct edges between executions in the history graph must be created based on the existing paths so that reachability between executions is preserved. The transitive closure of a graph has this property and therefore an algorithm finding this closure is needed.\footnote{\url{https://en.wikipedia.org/wiki/Transitive_closure}} Since reachability is preserved by only creating edges from an execution to the first execution encountered on every path from the execution, it is not required to find a complete transitive closure, as long as it is then done for every of the encountered executions. An example of this can be seen on figures \ref{fig:connect:3executions} and \ref{fig:connect:3executionstrans}.
	
	\begin{figure}
		\centering
		\def\svgwidth{0.15\columnwidth}
		\import{5connect/images/}{3executions.pdf_tex}
		\caption{3 executions before applying execution transitive closure.}
		\label{fig:connect:3executions}
	\end{figure}
	
	\begin{figure}
		\centering
		\def\svgwidth{0.22\columnwidth}
		\import{5connect/images/}{3executionswithtransitive.pdf_tex}
		\caption{3 executions after applying execution transitive closure.}
		\label{fig:connect:3executionstrans}
	\end{figure}
	
	\begin{algorithm}
		\begin{algorithmic}
		\Function{Execution Transitive-Closure}{graph}
			\State startFromSet $\leftarrow$ nodes with no incomming edges in graph
			\ForAll{fromNode in startFromSet}
				\State neighbourNodes $\leftarrow$ \Call{GetNeighboursOfNeighbours}{fromNode}
				\ForAll{neighbour in neighbourNodes}
					\If {neighbour is execution}
						\State graph $\leftarrow$ \Call{addEdge}{fromNode, neighbour, graph}
						\State startFromSet $\leftarrow$ \Call{add}{neighbour, startFromSet}
					\Else
						\State neighbourNodes $\leftarrow$ \Call{Union}{neighbour.neighbours, neighbourNodes}
					\EndIf
				\EndFor
			\EndFor
			\State 
			\Return graph
		\EndFunction
		\end{algorithmic}
		\caption{Transitive Closure Algorithm}
	\end{algorithm}

	
	% TODO: Collapsing
	\newpar After finding the transitive closures between executions it is possible to filter actions depending on their type. If a history describing an order of execution is desired, then every action except for \texttt{ExecutionStart} and \texttt{ExecutionEnd} must be removed from the history graph. 
	
	% TODO: Transitive reduction
	\newpar Redudant edges exist in a given history graph. These edges do not give any extra information, since the reachability to an action is the same. In prder to give a usable history, these redundant edges should be removed. 
	A subgraph of a given graph that has the same reachability but as few edges as possible, a minimum equivalent graph, is therefore desired. Finding this is possible by doing transitive reduction on the original graph, which then results in the minimum equivalent graph. 
	Therefore, if there is a path from an edge $x$ to an edge $y$ in graph G, there must also be a path from $x$ to $y$ in the transitive reduction of $G$, and vice versa. 
	
	% TODO: Collapsing
	
	% Filtering:
	It is necessary to filter actions depending on their type. If a history describing an order of execution is desired, then every action except for \texttt{ExecutionStart} and \texttt{ExecutionEnd} must be removed from the history graph. 
	
	% TODO: No cycles
	\section{Connecting Histories using Algorithms} % Giv bedre navn
	The implementation of determining happens-before relations works by looking at every node in the history graph, creating an edge between nodes of the given type wishing to be found, and adding the node the edge is going to to the list of nodes to check. The algorithm is implemented in such a way that the iteration through the history graph is a Breath First Search. 
	
	\section{Correctness of the Implementation} % Giv bedre navn
	