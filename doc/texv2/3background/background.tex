% !TeX root = ../DistributedConsensus.tex
% !TeX spellcheck = en_GB
\chapter{Background}\label{chap:background}
	\section{Dynamic Condition Response Graphs}
	Dynamic Condition Response Graphs (\textit{DCR graphs}) is a declarative, event-based process model. Instead of using sequences of state transitions like imperative process languages, declarative process languages uses sets of constraints to model the possible transitions in the process (hereafter \textit{workflow}). One benefit of DCR graphs is that parts of the workflow are allowed to happen multiple times if desired.
	
%	Since events in a DCR graphs are distributed and no algorithm for finding the order of execution currently exists, DCR graphs are well suited for developing an algorithm for determining history. 
%	Furthermore DCR graphs specify several types of directed edges in the graph, which provide useful information for determining order of execution.
	
	\newpar DCR graphs are in \cite{hildebrandt2011declarative} defined as a tuple $(E, M, Act, $\condition$, $\response$, \pm, l)$ where
	\begin{itemize}
		\item $E$ is the set of events
		\item $M$ is the marking, this is the state of the workflow. The marking is a triple containing three sets of events. The first set contains the events that has previously been excluded. The second set contains the events that is required to be executed or excluded. These are called the pending responses. The last set contains the events which are currently included.
		\item $Act$ is the set of actions. That is, a representation of what happens in the workflow, when a given event is executed.
		\item \condition (conditions) is a relation, which for all pairs of events which is present in the relation, means that the first event must be either excluded or executed for the second event to be executable.
		\item \response (responses) is a relation, which for all pairs of events which is present in the relation, means that after the first event has been executed the second event must either be executed or excluded at some point.
		\item $\pm$ defines the dynamic inclusion and exclusion of events. This partial function is a triple of two events and symbol defining whether the execution of the first event should result in an exclusion or inclusion of the second event. It is possible for an event to exclude itself.
		\item $l$ is the labelling function, assigning an action to each event.
	\end{itemize}
		
	Furthermore the article defines a distributed DCR graph as a DCR graph with a set of roles, a set of principals and a mapping function that assigns roles to principals and actions. This assignment means that if principal $P$ is assigned role $R$, and action $A$ is assigned $R$, then $P$ can execute $A$.
		
	\newpar
	\cite{hildebrandt2011safe} describes how events can be safely distributed. This is done by defining \textit{projections} and \textit{compositions} of DCR graphs.
	
	\newpar
	A projection of a DCR graph with respect to a subset of events of the graph and a subset of the labels of the graph. The label set must contain the labels of the events in the event set, as well as all labels of events that can affect the marking or the ability to execute an event in the projection, through relations.
	
	\newpar
	Proposition 1 in \cite{hildebrandt2011safe} defines how an execution in a projection corresponds to the execution of events in the entire DCR graph the projection was made on. In short it describes if and how a transition in the projection corresponds to a transition in the entire DCR graph and vice versa.
	
	\newpar
	The composition of two DCR graphs defines the rules for how these graphs can be glued back together. The requirement is to keep all events and relations as well as combining the markings in a consistent manner. These rules can be found in definition 5 of \cite{hildebrandt2011safe}.
	
	\newpar 
	In \cite{debois2015concurrency} Debois et al. describes the procedure for executing distributed events using a locking mechanism to ensure serial equivalence:
	
	\begin{quotation}
		The procedure for executing an event, in detail, is as follows. A component
		wishing to execute an event $e$ must first request\footnote{All components request locks in the same fixed order to prevent deadlocks.} and receive locks on all (local
		and remote) events that are in conflict (i.e., not independent ) with $e$ (thus, in
		particular, on itself). It then queries the state of remote events to determine if
		$e$ is currently executable. If it is, it instructs remote events affected by firing $e$
		to change state accordingly. Finally, it releases all locks.
	\end{quotation}

%	\newpar For example the events \textit{"Begin production"} and \textit{"Production finished"} can represent the start and end of the activity \textit{"Produce item X"}, which is an activity possibly containing several events. An event \textit{"Accept draft"}, can also represent a decision made or the event \textit{"Change password"} can represent an atomic event.
	
%	A DCR graph can model a \textit{workflow}, which represents a work process. The DCR graph can then be used to represent the current state of the process, to see what parts of the process have been completed and what parts of the process remain to be completed or \textit{executed}. 
	
%	The partitioning of the five types of relations in DCR graph makes modelling interconnected events possible, e.g. having an event in a process that makes another event non-executable. This is made possible by the \textit{exclusion} (\exclusion) relation, that excludes the other event and therefore makes in non-executable. 
	
%	Modeling an event that is dependent on the completion of another event is made possible by the \textit{condition} (\condition) relation, which makes it impossible to execute an event, unless the event that has a condition to it has been executed.
	
%	Modeling an event that can be excluded and then then re-included is made possible by the \textit{inclusion} (\inclusion) relation. 
	
%	Modeling an event that has to be executed in order for the event to be in an accepting state \todo{Find bedre phrasing for 'accepting'.} is made possible by the \textit{response} (\response) relation. If an event has a \textit{response} edge going to it in the DCR graph, the event is in a \textit{pending} state. The pending state signifies that the event should be executed in order for the process to be in an accepting state.
	
%	Users of a given DCR graph will execute events in order to change the state of the process the DCR graph is modelling. Events will have been executed in a certain order, which have resulted in the current state of the workflow. Several users can execute events concurrently in different locations. The events change state accordingly by communicating with reachable events. 
	
%	The implementation of a distributed system functioning as a DCR graph used in this project does not support the milestone relation. 
	\section{Distributed Systems}
		Distributed systems is an area of computer science which focus on the concepts, problems and design of computer systems where message transmission among processes are not negligible compared to the time between events in a single process. Traditionally these systems are distributed on computers in a network.
		
		\subsection{Serial Equivalence}
		Two concurrent processes are serially equivalent if the outcome of the two executing, is the same as if any one of the processes executed first followed by the other. In distributed systems this term is used for transactions across machines in a network and is especially important since message parsing over network connections introduce inconsistent and unpredictable delays. Therefore multiple messages can arrive at different times even if they were supposed to happen in extension of one another. Common implementations of achieving serial equivalence in distributed systems include locking, and optimistic concurrency control. In \cite{Coulouris:2011:DSC:2029110} these concepts are explored in depth.
		
		\subsection{Ordering of events}\label{subsec:orderingofevents}
		In \cite{Lamport:1978:TCO:359545.359563} Leslie Lamport examines and describes the ordering of events (not to be confused with DCR events) in distributed systems based on their occurrence in time. Applying these concepts is very helpful when determining the order of execution. 
		
		In set theory a total order is an order that is \textit{antisymmetric}, that is if $a \leq b$ and $b \leq a$ then $a = b$, as well as \textit{transitive}, that is if $a \leq b$ and $b \leq c$ then $a \leq c$, in addition to being \textit{total}, that is $a \leq b$ or $b \leq a$. For a total order to also be strict the \textit{irreflexivity} property must also be present that is $not$ $a < a$. A \textit{strict partial order} is similar to a \textit{strict total order} in that a strict partial order also has the \textit{transitive}, \textit{antisymmetry} and \textit{irreflexivity} properties, but not the \textit{totality} property.
		
		\newpar Lamport introduces so-called \textit{logical clocks}, which are simple timestamps, that makes it possible to determine the order of events in a distributed system. The clocks are \textit{logical} in the sense that they do not represent \textit{physical} time, since syncronising time in a distributed system is a non-trivial task. A logical clock is a simple counter, that is incremented for each message sent or received on a given event. 
		
		\newpar Lamport argues that if a given system is not distributed, it is possible to create a history of events where the ordering is total, due to the fact that it is possible for one process to use a logical clock to find out which event happened before another. In a distributed system however, this global ordering is not possible, since events have independent locical clocks that can have the same timestamp, and it is therefore not possible to determine what happened before what, \textbf{unless} the events have exchanged messages, in which case it is possible to determine what happens before what.
		
		\newpar Lamport describes these relations between events with the symbol $\rightarrow$ such that if $event$ $a$ happened before $event$ $b$ then $a \rightarrow b$. These relations can be created based on three cases, the first case is: if $event$ $a$ and $b$ happened on the same process and $a$ happened before $b$ measured with the local logical clock then $a \rightarrow b$. The second case: if process $i$ sends a message to process $j$ and $event$ $a$ is the event which initiates the sending and $event$ $b$ is the recieving of the message then $a \rightarrow b$. The third case is based on the transitive property such that if $a \rightarrow b$ and $b \rightarrow c$ then $a \rightarrow c$. If no relation exists between any event $a$ and $b$, the events are \textit{concurrent}, and logically \todo{Måske ikke rigtigt ord.} occur at the same time, even though this might not be the case physically. 
		
		%\newpar Lamport then introduces a function $C_i(event)$ where $C_i$ is the clock function on process $i$ that if $a \rightarrow b$ then $C_i(a) < C_i(b)$. This clock can then be used to describe in values which event happened first. \todo{maybe this section is not neccesary. Or maybe it needs to be introduced before}
		
		\subsection{Consensus}
		Concensus in distributed systems is the process of reaching agreement among the participants in the system on a proposed value. This is often achieved by using an election algorithm such as Paxos\cite{Lamport:1998:PP:279227.279229}. The Paxos algorithm cannot handle corrupted agents and can therefore not be used. Furthermore election algorithms requires all the agents of the election to be able to propose the value which can be agreed upon, but since each DCR event does not know nor is able to produce the entire history of the workflow, regular election algorithms cannot be used. 
		
	\section{Distributed DCR implementation}
		\todo[inline]{Vi har implementeret vores løsning med locking. Søren siger vi skal kigge på SFEN '12 eller '13.}
		As a prerequisite for this project, we have built upon an implementation that was developed during our second year project of the bachelor in software development at the IT University of Copenhagen.\footnote{For an in depth description of the original implementation the project including a report can be found at \url{https://github.com/andersfischernielsen/FlowIT-Second-Year-Project/}.}
		
		\newpar From the requirements of the Second Year Project:
		
		\begin{quotation}
			\noindent\textit{``The goal is to develop a functioning and correct, web-service based distributed workflow system that can support distributed coordination of workflows provided by the external and possibly international customers, and reconfigured if the workflow changes.''}
		\end{quotation}
		
		\newpar At the time of implementation, only Condition, Response, Inclusion, and Exclusion relations were required. The Milestone relation was presented, but we were not expected to implement this relation. \todo[inline]{Skal vi nævne spawn og nested workflows som vi ikke understøtter?}
		
		\newpar In order to fulfil the requirements we separated the project into smaller components:
		
		\begin{itemize}
			\item An event server
			\item A central server
			\item A client
			\item A parser and uploader to set up the workflows
		\end{itemize}
		
		\newpar The event server can contain zero or more events. For each of these events, the server persists the state of the event. The state consists of an identity, a name to show in the client, 3 boolean values for include, response, and execute respectively. Furthermore the initial values of these boolean values are saved in order to restore the workflow to the original state. Also the "outgoing" relations of an event are stored. Outgoing means that the event that has to contact another event knows which events to contact. For inclusions, exclusions, and responses this means that an executed event will send a request to update another events state. For conditions, the event that is about to execute sends requests to the events that must be either executed or excluded, in order to determine if these conditions are fulfilled.
		
		\newpar In order to achieve serial equivalence when executing, a locking strategy has been used for simplicity and because performance was not a priority for the project. How to implement this is described in section 5 of \cite{debois2015concurrency}. In order to prevent deadlocks an order of obtaining locks has been defined inside a workflow. The chosen strategy for this is to order the events to lock by their ID alphabetically.
		
		\newpar The central server contains information about workflows and the events that take part in the workflow. Each workflow is identified by an ID, that is chosen when creating the workflow. For each event in a workflow the ID of the event, as well as the address to the event machine containing that event is saved.
		
		\newpar The server furthermore contains information about users and the roles they are operating with. Password protection of users were not a requirement, but we implemented it as part of an extension to the project.
		
		\newpar As workflows can contain events that should only be visible and executable for different roles, it exposes information about which roles can access which events of the workflow. This enables an adversary to make requests on behalf of other roles, but since security was not a requirement of the original project, this flaw is still existing.
		
		\newpar The client is the one actually using the role information. When a user logs in, the server sends information about which roles the user has access to in the workflows he is connected to. The client can then filter the events of a chosen workflow, so the user only sees events where he or she has the rights to execute.
		
		There are no fine-grained access control, so read-only access to events, for instance, are not implemented.
		
		\newpar For each accessible event in a workflow, its name and state is shown. Furthermore there is a button used to execute an event. The button is deactivated if the event is not executable.
		
		\newpar As part of extended requirements added to the last part of the second year project, it should be possible to get an overview of what happened in a given workflow. This feature was called history, but was implemented by ordering each log entry by time stamp.\footnote{This history feature has of course been replaced with the outcome of this bachelor project.}
		
		\newpar Because the system had no way of undoing executions, and the evaluators of the project should be able to execute a given workflow multiple times, we inserted a button to reset a workflow. This button restored the initial state of the events, but did not clear the history.
		
		\newpar The parser is a tool developed to make it easier to translate workflows from DCRGraphs.net\todo[inline]{fodnote der forklarer dette værktøj?} into JSON\footnote{\url{http://json.org}\todo[inline]{Skal vi retfærdiggøre json?}} that can the be used to create workflows in the system. Later it became a tool used for this upload and creation of users as well. It was not intended for hand-in, but in the end we chose to do it, because it could be seen as an initial version of an administrating tool.
		
		\subsection{Changes to the original implementation}
			When starting the bachelors project, we discovered a few mistakes in the original project. For instance we checked conditions before locking the target event, which could mean that this conditioning event could change its state, and therefore change whether or not the condition was fulfilled, before the locks on other events would be obtained. A few mistakes of this kind has been corrected.
			
			\newpar Furthermore, the aforementioned history implementation has been thrown out, as well as the parser is now included in the main client project.

			\newpar The original project was hosted in Microsoft Azure\footnote{Microsofts cloud platform - \url{https://azure.microsoft.com/}}. In the aforementioned report, the user guide points to certain URLs that should contain the web services of the system. These web services are no longer running.