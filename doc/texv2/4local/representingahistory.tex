% !TeX spellcheck = en_GB
% !TeX root = ../DistributedConsensus.tex
\chapter{Representing a History}\label{chap:representing-a-history}
	This section looks at the representation of a History. Furthermore it discusses that a local history of a single event is totally ordered, as well as how to extract an order of execution from a totally ordered history.

	\newpar Before we can discuss the solutions to the problem definition, we have to define a few data structures that can be built and manipulated in order to achieve the goal: An order of execution.
	
	\newpar The smallest part of a history, called an \texttt{Action}, is defined as:
	
	\newpar
	\begin{definition}
		An \textit{\textbf{Action}} consists of the local events Id, the local time stamp of the action, as well as the Id of an event that took part in the action. Furthermore it knows the Id of the workflow in which it has happened, as well as the type of the action. In some cases the time stamp of the other event is included.
	\end{definition}
	
	\newpar The type of an action can be one of:
	\begin{multicols}{4}
		\begin{itemize}
			\item Includes
			\item IncludedBy
			\item Excludes
			\item ExcludedBy
			\item SetsPending
			\item SetPendingBy
			\item ChecksCondition
			\item CheckedCondition
			\item Locks
			\item LockedBy
			\item Unlocks
			\item UnlockedBy
			\item ExecuteStart
			\item ExecuteFinished
		\end{itemize}
	\end{multicols}
	\noindent By distinguishing between these kinds of actions, we can create a history for an Event.
	
	The reason for naming this entity an Action, is because the term Event is already used in DCR Graphs.
	
	Whenever an Event is performing an action related to its state, it saves in its local database, when the call has succeeded. An example of this is when an event is contacted because another event has a condition relation to it. When the other event executes, it updates the pending state of this event. When this happens, an action of type \texttt{SetPendingBy} is created in the database. The local time stamp of the action is a number generated by the database engine, starting from 1. Whenever a new action is saved to the database, it is assigned the next generated time stamp.
	
	When retrieving history for a single event, we need to have a data structure that supports the orderings of actions.
	
	\newpar When looking at a single event, the ordering of its actions are total. This is due to the fact that the database generates the next number as the local time stamp, and from that we can see which action happened at which time for that event.
	% TODO: Does this really require a formal proof that simultaneous actions cannot occur?
	Because no two actions are assigned the same local time stamp we have a total order of actions.
	
	\newpar This is not the case when the problem is extended with multiple events, though. Therefore we have chosen to represent a \texttt{History} as an acyclic graph. The choice has fallen on this data structure because of two factors:
	
	First: A graph supports partial ordering, which is an ordering where two elements can occur simultaneously, or more precisely, we cannot decide properly which element occurred before the other. This is due to the fact that we cannot rely on the clocks on different computers to be synchronous. Therefore we can only use \textit{Happens Before} relations with the use of message passing to decide when elements occur before each other.
	
	Second: Cycles cannot occur as this would imply that action A occurred before action B, which also happened before action A. This cannot be the case in a consistent history.\footnote{See more in \autoref{chap:consensusindcr}}
	
	\newpar This leads to the following definition of \texttt{History}:
	
	\newpar
	\begin{definition}
		A \textit{\textbf{History}} is an acyclic directed graph, where the nodes are actions, and the edges represent the order in which these actions have happened.
	\end{definition}
	
	\begin{figure}
		\centering
		\import{4local/images/}{singleexecution.pdf_tex}
		\caption{History representation of a single execution of the Event \texttt{ReadGasMeter}.}
		\label{fig:local:readgasmeterhistory}
	\end{figure}
	\newpar When creating a history from the local database, the actions are added as nodes in the history. Furthermore, because we have a total ordering locally we can add edges between the events that has happened after each other. An example of a local history is shown in \autoref{fig:local:readgasmeterhistory}.
	
	\newpar In the implementation, we have created two types representing an action. One, the \texttt{ActionModel} is used for storage in the ORM Entity Framework.\footnote{Object-Relational Mapping, used for mapping between objects in an object-oriented paradigm and relations in a relational database.}\footnote{\url{https://msdn.microsoft.com/en-us/data/ef.aspx}} As this mapping is set up in a C\# library, this had to be a C\# class as well. The \texttt{ActionModel} uses the enum \texttt{ActionType} to denote the type of action.
	
	The other type is created in the F\# module \texttt{HistoryConsensus} that contains most of the program described through this report. The \texttt{ActionType} in this module is a Discriminated Union, where each case represents a single type.\footnote{\url{https://msdn.microsoft.com/en-us/library/dd233226.aspx}}
	In this module, an action is uniquely identified by its source event id, combined with the local time stamp. In the module this is defined as a tuple named \texttt{ActionId}.
	The \texttt{Action} is then defined as a Record with the labels Id and CounterpartId that is \texttt{ActionId}s of the source event and the counterpart (if any). Futhermore the label \texttt{Type} contains the \texttt{ActionType} and \texttt{Edges} is a set of action ids, which points to the actions which happened immediately after this action.
	
	The \texttt{History} is implemented as a record (because of technical issues) with a single label called \texttt{Nodes}, containing a \texttt{Map} mapping from \texttt{ActionId} to the \texttt{Action} itself.
	
	\newpar As everything is handled locally at the event, no messages are passed between computers, other than the initial message that asks for the local history, as well as the response to this message. Retrieval of data from the database, as well as building the totally ordered history, takes time linear in the number of actions for that event.
	
	\newpar Malicious nodes are not discussed in this chapter, as you have to trust the event you contact for its local history, as it is the only source of exactly that history.
	% Logs, persist, retrieve, representing, ordering
