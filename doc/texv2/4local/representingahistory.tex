% !TeX spellcheck = en_GB
% !TeX root = ../DistributedConsensus.tex
\chapter{Representing a History}\label{chap:representing-a-history}
	This chapter defines the representation of a History. Furthermore it discusses that a local history of a single event is totally ordered, as well as how to extract an order of execution from a totally ordered history.

	\newpar Before we can discuss the solutions to the problem definition, we have to define a few data structures that can be built and manipulated in order to achieve the goal: An order of execution.
	
	\newpar The smallest part of a history, called an \texttt{Action}, is defined as:
	
	\begin{definition}
		An \textit{\textbf{Action}} consists of the local event's ID, the local time stamp of the action, as well as the ID of another event that took part in the action if any. Furthermore it includes the ID of the workflow in which it has happened, as well as the type of the action. In some cases the time stamp of the other event is included.
	\end{definition}
	
	\noindent The reason for naming this entity an action, is because the term event is already used in DCR graphs. Furthermore the the type of an action if defined as:
	
	\begin{definition}
		An \textit{\textbf{Action Type}} can be one of the following:
		\begin{multicols}{3}
			\begin{enumerate}
				\item Includes
				\item Included by
				\item Excludes
				\item Excluded by
				\item Sets pending
				\item Set pending by
				\item Checks condition
				\item Checked condition by
				\item Locks
				\item Locked by
				\item Unlocks
				\item Unlocked by
				\item Execute start
				\item Execute finish
			\end{enumerate}
		\end{multicols}
	\end{definition}
	
	\newpar The action types 1 through 8 is related to the functionality of DCR graphs, i.e. includes is an action that happens when an event A includes event B, similarly included by is an action that happens on event A when event B includes it. Action types 9 through 12 are specific to the implementation of DCR graphs we use. Action type 13 and 14 are action types that happen when an event starts executing and finishes executing. By distinguishing between these kinds of actions, we can create a history for a workflow consisting of a single event. 
	
	\newpar Whenever an action happens on an event it is saved in the database of the event. The local time stamp of the action is generated by the database engine, starting from 1 and incrementing for each action saved. With these timestamps we can compare each action with any other action and see which happened first. This is due to the fact that no two actions are assigned the same local time stamp and therefore the actions are in total order.

	\newpar This is unfortunately not the case when the problem is extended with multiple events, though. Therefore we have chosen to represent a \texttt{History} as an acyclic graph. The choice has fallen on this data structure because of two factors:
	
	\begin{enumerate}
		\item A graph supports partial ordering, which is an ordering where two elements can occur simultaneously, or more precisely, we cannot decide properly which element occurred before the other. This is due to the fact that we cannot rely on the clocks on different computers to be synchronous. Therefore we can only use \textit{Happens Before} relations with the use of message passing to decide when elements occur before each other.
	
		\item Cycles cannot occur as this would imply that action A occurred before action B, which also happened before action A. This cannot be the case in a consistent history.\footnote{See more in \autoref{chap:consensusindcr}}
	\end{enumerate}

	
	\newpar This leads to the following definition of \texttt{History}:
	
	\begin{definition}
		A \textit{\textbf{History}} is an acyclic directed graph, where the nodes are actions, and the edges represent the order in which these actions have happened.
	\end{definition}
	
	\begin{figure}
		\centering
		\import{4local/images/}{singleexecution.pdf_tex}
		\caption{History representation of a single execution of the Event \texttt{ReadGasMeter}.}
		\label{fig:local:readgasmeterhistory}
	\end{figure}
	\newpar When creating a history from the local database, the actions are added as nodes in the history, and since the ordering is total we can add edges between consecutive actions. An example of a local history is shown in \autoref{fig:local:readgasmeterhistory}.
	
	\newpar In the implementation, we have created two types representing an action. One, the \texttt{ActionModel} is used for storage in the ORM Entity Framework.\footnote{Object-Relational Mapping, used for mapping between objects in an object-oriented paradigm and relations in a relational database.}\footnote{\url{https://msdn.microsoft.com/en-us/data/ef.aspx}} As this mapping is set up in a C\# library, this had to be a C\# class as well. The \texttt{ActionModel} uses the enum \texttt{ActionType} to denote the action type.
	
	The other type is created in the F\# module \texttt{HistoryConsensus} that contains most of the program described throughout this report. The \texttt{ActionType} in this module is a discriminated union, where each case represents a single type.\footnote{\url{https://msdn.microsoft.com/en-us/library/dd233226.aspx}}
	In this module the type \texttt{ActionId} is defined as a tuple of an event ID and a local timestamp. The \texttt{Action} is then defined as a record  with two \texttt{ActionId}s, a local and a counterpart, as well as an \texttt{ActionType}.
	
	The \texttt{History} is implemented as a record with a single label called \texttt{Nodes}, containing a \texttt{Map} mapping from \texttt{ActionId} to the \texttt{Action} itself.
	
	\newpar As everything is handled locally at the event, no messages are passed between computers, other than the initial request for the local history, as well as the response. Retrieval of data from the database, as well as building the totally ordered history, takes time linear in the number of actions for that event, since the database is sorted and each event is accessed and used one at a time only once.
	
	\newpar In this limited case where only one event creates history, you have to trust that the event you contact is not malicious. If you cannot trust that event to be behaving correctly, you have no guarantees that the history is correct, as it is the only source of its local history. Handling malicious nodes will be discussed further in the following chapters.
	% Logs, persist, retrieve, representing, ordering
