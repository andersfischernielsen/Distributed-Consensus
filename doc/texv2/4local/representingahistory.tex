% !TeX spellcheck = en_GB
% !TeX root = ../DistributedConsensus.tex
\chapter{Representing a History}\label{chap:representing-a-history}
	This chapter defines the representation of a History. Furthermore it examines why a local history of a single event must be totally ordered and describes how it is possible to extract an order of execution from a totally ordered history.
	
	\newpar	In a DCR Graph with a single event, where this event has been executed an arbitrary number of times, it is wanted to find the order in which these executions have happened, a so called \textit{order of execution}.
	
	\newpar	It is therefore necessary to define how to represent an execution. Recall that an execution can affect other events (including itself), for instance it can exclude itself. Therefore an execution can be described as a set of effects. An execution has different effects, such as including another event or checking a condition, and therefore these effects need to be distinguished by time and type. Lamport's logical clocks can be used for time stamps.\footnote{See \autoref{subsec:orderingofevents} - \nameref{subsec:orderingofevents}}
	
	\newpar An event can see an effect from two different sides\todo{bedre udtryk}. Either the event is affecting another event, or the event is being affected by another event, a so called \textit{\textbf{counterpart}}.

	\noindent\hrulefill	
	\begin{definition}
		In a given effect where two events A and B is part of the effect, event B is \textbf{\textit{Counterpart}} of event A and event A is counterpart of event B.
		
		\noindent\hrulefill
	\end{definition}
	
	\newpar This introduces more types of effects. Keeping information about the counterpart and the event itself is beneficial in DCR Graphs with multiple events. Why this is the case is examined further in \autoref{chap:connecting-histories} onwards.
	
	\newpar Because an execution can have happened any time in the past, it is required to persist the effects for later retrieval.
	
	\newpar An effect has been named \textit{\textbf{Action}} because it can be seen as an action performed by an event in the DCR Graph. An \textit{\textbf{Action}} is defined as:
	
	\begin{definition}
		An \textit{\textbf{Action}} consists of the ID of an event, the time stamp of the action, the ID of a counterpart as well as  the type of the action. In some cases the counterpart time stamp is included.
	\end{definition}
	
	\newpar	The type of an effect is defined as an \textit{\textbf{Action Type}}:
	
	\begin{definition}
		An \textit{\textbf{Action Type}} can be one of the following:
		\begin{multicols}{3}
			\begin{enumerate}
				\item Includes
				\item Included by
				\item Excludes
				\item Excluded by
				\item Sets pending
				\item Set pending by
				\item Checks condition
				\item Checked condition by
				\item Locks
				\item Locked by
				\item Unlocks
				\item Unlocked by
				\item Execute start
				\item Execute finish
			\end{enumerate}
		\end{multicols}
	\end{definition}
	
	\newpar The action types 1 through 8 is related to the functionality of DCR graphs, i.e. includes is an action that happens when an event A includes event B, similarly included by is an action that happens on event A when event B includes it. Action types 9 through 12 are specific to the implementation of DCR graphs we use. Action type 13 and 14 are action types that happen when an event starts executing and finishes executing.
	
	\newpar In the implemented solution persistent storage is achieved by the use of a database supporting concurrency. This also provides us with the functionality to generate logical time stamps easily. Whenever an action happens on an event it is saved in the database. The logical time stamp of the action is generated by the database engine, starting from 1 and incrementing for each action saved.
	
	\newpar Now that a representation of actions has been defined, it is necessary to define a way to connect these actions in order to create an order of execution.
	
	\newpar With the timestamps of actions we can compare each action with any other action and see which happened first. Due to the requirement that executions in the DCR Graph implementation must happen in a serially equivalent manner, for all actions in execution A must either happen before or after all actions in execution B. This can be defined mathematically when actions are compared using timestamps:
	
	\begin{center}
		$\forall_{x \in E_A}\forall_{y \in E_B} . (x < y) \lor \forall_{x \in E_A}\forall_{y \in E_B} . (y < x)$ \todo[inline]{Totality for executions?}
	\end{center}

	\begin{center}
		$max_{E_A} < min_{E_B} \lor max_{E_B} < min_{E_A}$
	\end{center}
	\todo{which to keep?}
	
	\newpar Due to this property, executions happening on the same event can be ordered, in fact \textit{strictly totally ordered}. A strict total order can be represented as a list, but this is unfortunately not the case when the problem is extended with multiple events. Recall that Lamport states \todo{hvordan fandt han ud af det?} that it is not always possible to establish a strict total order of events in a distributed system. It is however possible to find a strict partial order which can be represented by an acyclic graph.\footnote{See \autoref{subsec:orderingofevents} - \nameref{subsec:orderingofevents}} 
	
	\newpar One can easily argue that a strict partial order fits ordering of actions because:
	
	\todo[inline]{rephrase the following argument, so that it fits strict partial ordering instead of an acyclic graph and the history definition so it is on a higher abstraction level before going into detail.}
	\begin{enumerate}
		\item Actions can be represented as nodes in the graph. The ordering of actions can be represented as the edges between the nodes.
		\item An acyclic graph can represent concurrent actions by having two nodes A and B, where there exists no path from A to B and from B to A.
		\item Since action A cannot occur both before and after action B, cycles must not exist in the graph.
	\end{enumerate}
	
	\newpar This leads to the following definition of \texttt{History}:
	
	\begin{definition}
		A \textit{\textbf{History}} is an acyclic directed graph, where the nodes are actions, and the edges represent the order in which these actions have happened, that is if there is an edge from action A to action B, this means that action A happened before action B.
	\end{definition}
	
	\begin{figure}
		\centering
		\import{4local/images/}{singleexecution.pdf_tex}
		\caption{History representation of a single execution of the Event \texttt{ReadGasMeter}.}
		\label{fig:local:readgasmeterhistory}
	\end{figure}
	\newpar When creating a history from the local database, the actions are added as nodes in the history, and since the ordering is total we can add edges between consecutive actions. An example of a local history is shown in \autoref{fig:local:readgasmeterhistory}.
	
	\newpar In the implementation, we have created two types representing an action. One, the \texttt{ActionModel} is used for storage in the ORM Entity Framework.\footnote{Object-Relational Mapping, used for mapping between objects in an object-oriented paradigm and relations in a relational database.}\footnote{\url{https://msdn.microsoft.com/en-us/data/ef.aspx}} As this mapping is set up in a C\# library, this had to be a C\# class as well. The \texttt{ActionModel} uses the enum \texttt{ActionType} to denote the action type.
	
	The other type is created in the F\# module \texttt{HistoryConsensus} that contains most of the program described throughout this report. The \texttt{ActionType} in this module is a discriminated union, where each case represents a single type.\footnote{\url{https://msdn.microsoft.com/en-us/library/dd233226.aspx}}
	In this module the type \texttt{ActionId} is defined as a tuple of an event ID and a local timestamp. The \texttt{Action} is then defined as a record  with two \texttt{ActionId}s, a local and a counterpart, as well as an \texttt{ActionType}.
	
	The \texttt{History} is implemented as a record with a single label called \texttt{Nodes}, containing a \texttt{Map} mapping from \texttt{ActionId} to the \texttt{Action} itself.
	
	\newpar As everything is handled locally at the event, no messages are passed between computers, other than the initial request for the local history, as well as the response. Retrieval of data from the database, as well as building the totally ordered history, takes time linear in the number of actions for that event, since the database is sorted and each event is accessed and used one at a time only once.
	
	\newpar In this limited case where only one event creates history, you have to trust that the event you contact is not malicious. If you cannot trust that event to be behaving correctly, you have no guarantees that the history is correct, as it is the only source of its local history. Handling malicious nodes will be discussed further in the following chapters.
	% Logs, persist, retrieve, representing, ordering
