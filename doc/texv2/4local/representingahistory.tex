% !TeX spellcheck = en_GB
% !TeX root = ../DistributedConsensus.tex
\chapter{Representing a History}\label{chap:representing-a-history}
	This chapter defines the representation of a History. Furthermore it examines why a local history of a single event must be totally ordered and describes how it is possible to extract an order of execution from a totally ordered history.
	
	\newpar	In a DCR Graph with a single event, where this event has been executed an arbitrary number of times, it is wanted to find the order in which these executions have happened, a so called \textit{order of execution}.
	
	\newpar	It is therefore necessary to define how to represent an execution. Recall that an execution can affect other events (including itself), for instance it can exclude itself. Therefore an execution can be described as a \textit{set of effects}. An execution has different effects, such as including another event or checking a condition, and therefore these effects need to be distinguished by time and type. Lamport's logical clocks can be used for time stamps.\todo{maybe not ref logical clocks}\footnote{See \autoref{subsec:orderingofevents} - \nameref{subsec:orderingofevents}} Furthermore an event, outside of its own execution, can be affected by another event's execution. Therefore we can say that, either the event is \textit{affecting} another event, or the event is being \textit{affected} by another event, which brings us to the definition of a so called \textit{\textbf{counterpart}}:

	\begin{definition}
		In a given effect where two events A and B is part of the effect, event B is \textbf{\textit{Counterpart}} of event A and event A is counterpart of event B.
	\end{definition}
	
	\newpar Information about the event itself and the counterpart is beneficial to creating history in DCR Graphs with multiple events. Why this is the case is examined further in \autoref{chap:connecting-histories} onwards, therefore this information must be a part of the representation of an execution.
	
	\newpar Because an execution can have happened any time in the past, it is required to persist the effects for later retrieval.
	
	\newpar The representation of an effect has been named \textit{\textbf{Action}} because it can be seen as an action performed by an event in the DCR Graph. An \textit{\textbf{Action}} is defined as:
	
	\begin{definition}
		An \textit{\textbf{Action}} consists of the ID of an event, the time stamp of the action, the ID of a counterpart as well as  the type of the action. In some cases the counterpart time stamp is included.
	\end{definition}
	
	\newpar	The type of an effect is defined as an \textit{\textbf{Action Type}}:
	
	\begin{definition}
		An \textit{\textbf{Action Type}} can be one of the following:
		\begin{multicols}{3}
			\begin{enumerate}
				\item Includes
				\item Included by
				\item Excludes
				\item Excluded by
				\item Sets pending
				\item Set pending by
				\item Checks condition
				\item Checked condition by
				\item Locks
				\item Locked by
				\item Unlocks
				\item Unlocked by
				\item Execute start
				\item Execute finish
			\end{enumerate}
		\end{multicols}
	\end{definition}
	
	\newpar The action types 1 through 8 are related to the functionality of DCR graphs, i.e. includes is an action that happens when an event A includes event B, similarly included by is an action that happens on event A when event B includes it. Action types 9 through 12 are specific to the implementation of DCR graphs in use. Action types 13 and 14 are action types that happen when an event starts executing and finishes executing. An Action is part of an execution if the Event ID is the same and it has happened between a pair of \textit{Execute start} and \textit{Execute finish} actions.\todo{Den sidste sætning er lidt underlig}
	
	\newpar In the implemented solution persistent storage is achieved by the use of a database supporting concurrency. This also provides us with the functionality to generate logical time stamps easily. Whenever an action happens on an event it is saved in the database. The logical time stamp of the action is generated by the database engine, starting from 1 and incrementing for each action saved.\todo{Måske skal det lige nævnes at flere events kan bo på samme server og at tidsstempler derfor ikke nødvendig\-vis er kontinuere lokalt set}
	
	\newpar Now that a representation of actions has been defined, it is necessary to define a way to connect these actions in order to create an order of execution. 
	
	\newpar With the timestamps of actions we can compare each action with any other action and see which happened first. This information, together with an ID check, can then be used to see which \textit{Execution Start} and \textit{Execution Finish} an action has happened in between and we can conclude which execution it belongs to. Due to the requirement that executions in the DCR Graph implementation must happen in a serially equivalent manner, for all actions in execution A must either happen before or after all actions in execution B. This can be defined mathematically when actions are compared using timestamps:
	
	\begin{center}
		$\forall_{x \in E_A}\forall_{y \in E_B} . (x < y) \lor \forall_{x \in E_A}\forall_{y \in E_B} . (y < x)$ \todo[inline]{Totality for executions?}
	\end{center}

	\begin{center}
		$max_{E_A} < min_{E_B} \lor max_{E_B} < min_{E_A}$
	\end{center}
	\todo{which to keep?}
	
	\newpar Due to this property, executions happening on the same event can be ordered, in fact \textit{strictly totally ordered}. A strict total order can be represented as a list, but this is unfortunately not the case when the problem is extended with multiple events. Recall that Lamport states \todo{hvordan fandt han ud af det?} that it is not always possible to establish a strict total order of events in a distributed system. \footnote{See \autoref{subsec:orderingofevents} - \nameref{subsec:orderingofevents}} 
	
	\newpar One can easily argue that a strict partial order fits ordering of actions because:
	\begin{enumerate}
		\item An action A cannot happen before itself, therefore the order must be irreflexive.
		\item Actions A and B, cannot both be happening before and after each other, therefore the order must be anti-symmetric.
		\item If Action A happened before action B and B in addition happened before C then A happened before C and the order must be therefore transitive.
		\item Actions can in distributed systems be concurrent and the order can therefore not be total.
	\end{enumerate}
	\newpar These are the properties of strict partial order\todo{source} and therefore this ordering is optimal for the problem at hand. To represent this type of order a directed acyclic graph can be used since it allows for the same properties
	\begin{enumerate}
		\item Actions can be represented as nodes in the graph. The ordering of actions can be represented as the edges between the nodes.
		\item Paths from one action to another can be found by going over edges. Finding these paths explain which transitive relations each action has.
		\item A graph can represent concurrent actions by having two nodes A and B, where there exists no path from A to B and from B to A.
		\item The acyclic requirement ensure that action A cannot occur both before and after action B since there is no path from both A and B and from B to A.
		\item The acyclic requirement also ensures that action A cannot have an edge to itself, implying that it happened before itself.
	\end{enumerate}
	
	\newpar This leads to the following definition of \texttt{History}:
	
	\begin{definition}
		A \textit{\textbf{History}} is a strict partial order of actions.
	\end{definition}
	
	\newpar
	We have chosen to represent a history as a directed acyclic graph, where nodes are actions and edges represent the order in which the actions have happened.
	
	\begin{figure}
		\centering
		\import{4local/images/}{singleexecution.pdf_tex}
		\caption{History representation of a single execution of the Event \texttt{ReadGasMeter}.}
		\label{fig:local:readgasmeterhistory}
	\end{figure}
	\newpar When creating a history from the local database, the actions are added as nodes in the history, and since the ordering is total we can add edges between consecutive actions. An example of a local history is shown in \autoref{fig:local:readgasmeterhistory}.
	
	
%	\newpar In the implementation, we have created two types representing an action. One, the \texttt{ActionModel} is used for storage in the ORM Entity Framework.\footnote{Object-Relational Mapping, used for mapping between objects in an object-oriented paradigm and relations in a relational database.}\footnote{\url{https://msdn.microsoft.com/en-us/data/ef.aspx}} As this mapping is set up in a C\# library, this had to be a C\# class as well. The \texttt{ActionModel} uses the enum \texttt{ActionType} to denote the action type.
%	
%	The other type is created in the F\# module \texttt{HistoryConsensus} that contains most of the program described throughout this report. The \texttt{ActionType} in this module is a discriminated union, where each case represents a single type.\footnote{\url{https://msdn.microsoft.com/en-us/library/dd233226.aspx}}
%	In this module the type \texttt{ActionId} is defined as a tuple of an event ID and a local timestamp. The \texttt{Action} is then defined as a record  with two \texttt{ActionId}s, a local and a counterpart, as well as an \texttt{ActionType}.
%	
%	The \texttt{History} is implemented as a record with a single label called \texttt{Nodes}, containing a \texttt{Map} mapping from \texttt{ActionId} to the \texttt{Action} itself.
%	
%	\newpar As everything is handled locally at the event, no messages are passed between computers, other than the initial request for the local history, as well as the response. Retrieval of data from the database, as well as building the totally ordered history, takes time linear in the number of actions for that event, since the database is sorted and each event is accessed and used one at a time only once.
%	
	\newpar In the case where a single event creates history, the event contacted has to be trusted as not being malicious. If the event cannot be trusted as behaving correctly, there are no guarantees that the history is correct, as it is the only source of its local history. Handling malicious nodes will be discussed further in the following chapters.
