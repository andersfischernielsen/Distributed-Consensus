% !TeX root = ../DCR-Consensus.tex
% !TeX spellcheck = en_GB

\section{Stitch}
\subsection{Goal} % Hvad er problemet
The goal of the algorithm is, given a collection of partially ordered histories, to merge the histories into one history which includes all of the actions of the histories, such that the resulting history remains partially ordered in accordance to the ruleset described in \autoref{chap:domainanalysis}.

%actions should not be understood as executions only but all the different kinds of actions, see action description.
%A partially ordered graph should not contain cycles.

\subsection{Implementation} % hvordan løses det
To solve the problem a data structure, which represents the partial ordered history, has to be introduced. This structure can be \todo{måske skriv det her om når vi har implementeret skidtet.} a directed graph where the \texttt{nodes} represent \texttt{actions} and the \texttt{edges} represent the order in which these actions were made. Because a action can have multiple preceding actions a tree structure is not feasible. It is important to note, though, that the graph cannot contain cycles, as this would imply that a single action should happen both before and after another action.

\newpar Such a data structure requires the following functions:
\begin{algorithm}
\begin{algorithmic}
\Function{Add} {graph node}
	\If {EXISTS graph node}
	    \State union matching node edge sets.
	\Else
	    \State Add node to list of nodes.
	\EndIf
\EndFunction

\State\State

\Function{Add}{graph edge}
	\State add edge to source node.
\EndFunction

\State\State

\Function{stitch}{localgraph graphlist}
\ForAll{graph in graphlist}
	\ForAll{node in graph}
		\State\Call{Add}{localgraph node}
	\EndFor
\EndFor
\ForAll{node1 in localgraph}
	\ForAll{node2 in localgraph}
		\If{node1 and node2 does not have an edge}\todo[inline]{Shouldn't these if statements be changed? I think it makes sense to check whether or not the nodes match before we are looking at their relations?}
			\If{node1 and node2 has a happen before relation}
				\State create edge from node1 to node2
			\EndIf
		\EndIf
	\EndFor
\EndFor
\State cyclecheck
\EndFunction
\end{algorithmic}
\caption{Pseudo-code for the implementation of the Stitch-algorithm.}
\end{algorithm}

\newpar The idea is to take the local history, which is in total order, and merge the other histories into the local one. By examining the different events in is checked whether or not couples of them represents the two ends of the same history (For instance: \texttt{Includes} should be preceded by \texttt{Included By}). This is decided by having a look at the type of the entry as well as the participating \texttt{Events}.

\newpar If two histories does not have common interactions we have a disjoint graph. As the missing history can be fetched by a higher level in the recursion, this history is kept, and no further action needs to be taken.

\newpar Either after each history has been stitched or when all histories has been stitched, a graph cycle check can be initiated. Because it does not make sense to have cycles in the history, something must have gone wrong if one appears. This case probably appears if one of the external histories has been tampered with, and therefore it makes sense to find the source(s) of the cycle, to see if a corrupt \texttt{Event} can be found.\todo[inline]{Beslut hvordan vi håndterer disse. Skal vi fortsætte som før, eller skal historikkaldet afbrydes?}

\subsection{Discussion} % bliver problemet løst
Since the a local history of an event must be in a total order due to the strict timeline on an event, we know that we at least have some ordering in place. These histories can then be put in the same data structure. Since the ruleset described in \autoref{chap:domainanalysis}, explain explicit rules about which actions must occur before others if their IDs and action types correspond, we can add edges between the total orderings. 

By doing so a partial order between parts of the different graphs is created. Over the course of the algorithm more and more explicity should appear as more and more of the ordering should be creating.\todo{<- what? Wat wat wat?} Even in the case that some actions cannot be used, it may be possible to later on since these actions are still kept in the graph. % this is so much bullshat. I can't even.

\newpar If two actions on the same event happen, an edge from the first occuring action to the second is created and therefore we know the order of the two. 
If two actions on different events happen, and they do not correspond, each of the actions are placed in the graph but without a edge, showing that we have no knowledge about which event occurred first.
If two actions on different events happen, and a happen-before rule apply, meaning that fromID and ToID correspond as well as the type of the action correspond, an edge is created between the two indicating which one happened first. 
By transitive closure we know that if action A happened before action B, and action B happened before action C, action A happened before action C, and therefore we can follow the edges of the graph and see which happen before which.
If no cycles exist in the workflow then we cannot have situations where action A happened before action B, and action B happened before action C and action C happened before action A - resulting in a disruption of the order. % maybe less bullshit.

\subsection{Performance} % hvor godt løses det
This algorithm runs in \texttt{O(N$^2$)} where N is the number of actions in the combined graphs.

