% !TeX root = ../DCR-Consensus.tex
% !TeX spellcheck = en_GB

\section{Stitch}
\subsection{Goal} % Hvad er problemet
The goal of the algortithm is, given a collection of partially ordered histories, to merge the histories into one history which includes all of the logs of the histories, such that the resulting history remains partially ordered in accordance to the ruleset described in \autoref{chap:domainanalysis}.

%Logs should not be understood as executions only but all the different kinds of logs, see log description.
%A partially ordered graph should not contain cycles.

\subsection{Implementation} % hvordan løses det
To solve the problem a datastructure which represents the partial ordered history has to be introduced. Such a datastructure requires the following functions:

\begin{algorithmic}
\Function{Add} {graph node}
	\If {EXISTS graph node}
	    \State union matching node edge sets.
	\Else
	    \State Add node to list of nodes.
	\EndIf
\EndFunction

\State\State

\Function{Add}{graph edge}
	\State add edge to source node.
\EndFunction

\State\State

\Function{stitch}{localgraph graphlist}
\ForAll{graph in graphlist}
	\ForAll{node in graph}
		\State\Call{Add}{localgraph node}
	\EndFor
\EndFor
\ForAll{node1 in localgraph}
	\ForAll{node2 in localgraph}
		\If{node1 and node2 does not have an edge}
			\If{node1 and node2 has a happen before relation}
				\State create edge from node1 to node2
			\EndIf
		\EndIf
	\EndFor
\EndFor
\State cyclecheck
\EndFunction
\end{algorithmic}

\subsection{Discussion} % bliver problemet løst
Since the a local history of an event must be in a total order since we have a strict timeline on an event, we know that we atleast have some ordering in place. Then these histories can be put in the same data structure. Then since the ruleset described in \autoref{chap:domainanalysis}, explain explicit rules about which logs must occur before others if their IDs and log types corrospond we can add edges between the total orderings and by doing so creating a partial order between parts of the different graphs. Over the course of the algorithm more and more explecitity should appear as more and more of the ordering should be creating. Even in the case that some logs cannot be used, it may be possible to later on since these logs are still kept in the graph. % this is so much bullshat.

\newpar If two logs on the same event happen, an edge from the first occuring log to the second is created and therefore we know the order of the two. 
If two logs on different events happen, and they do not corrospond, each of the logs are placed in the graph but without a edge, showing that we have no knowledge about which event occured first.
If two logs on different events happen, and a happen-before rule apply, meaning that fromID and ToID corrospond as well as the type of the log corrospond, an edge is created between the two indicating which one happened first. 
By transitive clousure we know that if log A happened before log B, and log B happened before log C, log A happened before log C, and therefore we can follow the edges of the graph and see which happen before which.
If no cycles exist in the workflow then we cannot have situations where log A happened before log B, and log B happened before log C and log C happened before log A - resulting in a disruption of the order. % maybe less bullshit.

\subsection{Performance} % hvor godt løses det
This algorithm runs in \texttt{O(N$^2$)} where N is the number of logs in the combined graphs.

