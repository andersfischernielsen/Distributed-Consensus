% !TeX root = ../DCR-Consensus.tex
% !TeX spellcheck = en_GB

\section{Produce}
\subsection{Goal} % Hvad er problemet
Given a DCR graph, the algorithm should fetch and merge the histories of each event in the graph into one history, such that the resulting history is partially ordered in accordance to the ruleset described in \autoref{chap:domainanalysis}. 

%Correcness should be based on:
%\begin{itemize}
%    \item How many nodes' history gets fetched in the workflow (higher is better).
%    \item How rendundant the data is (higher redundancy is better).
%    \item How well it handles cycles in the graph
%\end{itemize}

\subsection{Implementation} % hvordan løses det
To create the partially ordered history, all reachable events from a single event must be included. Reachable events are events where a path of relations from event to event exists, starting from the first event. This is accomplished by recursively contacting neighbouring events and asking them for their history while stiching the neighbours' history with its own history. 

\newpar DCR graphs can form graphs with cycles, and thefore a mechanism for handling these needs to be implemented. This is done by using a trace of previously contacted events and handling when a cycle is detected.

\newpar The implementation uses two lists, called \texttt{request trace} and \texttt{wait for}.
The algorithm propagates throughout the graph using recursion with checks during execution in order to avoid infinite cycles of requests.

\newpar When an event receives a request for its history, it adds every reachable event from itself to \texttt{wait for}, and sends requests to these events for history. The request for history includes a \texttt{request trace}, which is initially empty. Outgoing history requests from an event include the received \texttt{request trace}, with the ID of the event appended. This enables events to do cycle detection.

\newpar When an event receives a history request, it checks any event ID in the received \texttt{request trace} exists in its own \texttt{wait for}. Any event ID in \texttt{wait for} that exists in \texttt{request trace} is removed and the history of the event is returned to the requester. 
Cycles are therefore avoided, since a chain of events are unable to wait for any event in the chain.


\subsubsection*{Pseudocode}
\begin{algorithmic}
	\State Event receives request for history with a \texttt{request trace}, $T$.
	\State Event has internal \texttt{wait for}, $W$
	\State
	\State $W\gets W::$ reachable events \Comment Add all reachable events to \texttt{wait for}.
	\If {$W=\emptyset$}
	\Return own history
	\Else
	\State $W\gets W-T$ \Comment Remove every event in $T$ from $W$.
	\State $T\gets T::ownID$ \Comment Append own event ID to $T$.
	\State
	\ForAll {$w$ in $W$} 
	\State request history from $w$ with $T$ \Comment Request from neighbours with new \texttt{trace}.
	\EndFor
	\State wait for receiving histories
	\State stitch received histories with own history
	\State
	\Return stitched histories
	\EndIf
\end{algorithmic}


\subsection{Discussion} % bliver problemet løst

\subsection{Performance} % hvor godt løses det
This algorithm has a worst case message performance of O(2*N$^2$) where N is the number of events in the system. This situation occurs when all events have relations to all other events in the graph. Realistically though this situation will rarely occur.