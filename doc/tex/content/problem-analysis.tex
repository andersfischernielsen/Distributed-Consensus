% !TeX root = ../DCR-Consensus.tex
% !TeX spellcheck = en_GB
\chapter{Domain Analysis}
\label{chap:domainanalysis}

\section{What is a History}
\begin{definition}
	An \textit{\textbf{Action}}\index{Action|(} contains the following information:
	\begin{itemize}
		\item The Id of the source Event, this is the Event that has logged the action.
		\item The time stamp of the action local to the source Event.
		\item The Id of the participating Event, this is the Event that are being contacted, or the Event who has initiated the action.
		\item The type of the Action, i.e. \texttt{IncludedBy}.
	\end{itemize}
	
	The reason that an Action is not called Event\index{Event}, is because this term is used for an Event in the DCR Graph workflow.
	\index{Action|)}
\end{definition}

\begin{definition}\label{definition:historya}
	A \textit{\textbf{History}}\index{History} is a set of Actions.\index{Action}
\end{definition}

\begin{lemma}\label{lemma:partialorder}
	A set is in partial order if the relation between elements in the set is reflexive, antisymmetric, and transitive.
	If S is a partially ordered set and every two elements of S are comparable, S is called a totally ordered or linearly ordered set, and the relation between elements in the set is a total or linear order.
	\todo[inline]{Source: Discrete Mathematics and its Applications, 7th ed. - Kenneth H. Rosen - Afsnit 9.6, Partial Orderings}
	
	\newpar If Action $A$ has timestamp $a$, Action $B$ has timestamp $b$ and Action $C$ has timestamp $c$ in the local history H, and $a \geq a$ for every timestamp $a$, the relation $\geq$ is reflexive. If $a \geq b$ and $b \geq a$, then $a = b$. Therefore the relation $\geq$ is antisymmetric. Finally, $\geq$ is transitive because $a \geq b$ and $b \geq c$ imply that $a \geq c$. It follows that $\geq$ is a partial ordering on the set of timestamps. The same properties are present for $\leq$. 
	
	\newpar A local history is therefore totally ordered since the source Event knows the timestamps of all Actions, and the relation between timestamps of Actions is reflexive, antisymmetric and transitive. 
	
	\newpar In a workflow these local histories are put together. This creates the possibility of having histories that cannot be totally ordered, because there haven't been exchanged messages between the source Events between the actions.\todo{Dette forstår jeg ikke. - Fisk} This means that it is not possible to decide between all pairs of actions, which action happened first.
	
	There is one limitation on the order of the actions that must be fulfilled by any history, locally or globally. That is, that the history cannot contain cycles as this would imply that two (or more) actions would have to happen before the other.
	
	\todo[inline]{Lav et argument, eller find nogle andre der har defineret at en total order også er en partial order. (I forhold til Wiki-definitionen ovenfor, er det er en partial order ikke har den 3. begrænsning, men at det ellers er det samme, og derfor er partial order en svagere definition af total order.)}
	
	This creates the need for a history of partial order.
\end{lemma}

\newpar Because of \autoref{lemma:partialorder} we can update \autoref{definition:historya} to the following definition:

\begin{definition}
	A \textit{\textbf{History}}\index{History} is a \textit{partially ordered} set of Actions.\index{Action}
	\label{definition:historyb}
\end{definition}

\section{Relations between logs}
\label{sec:relations}
All logs have the form (\#Number, FromID, RelationType, ToID/ByID)
\subsection{Inclusion}
\begin{tabularx}{\textwidth}{|*{3}{>{\raggedright\arraybackslash}X|}}
  \hline
  Relation & Event1 Log & Event2 Log \\
  \hline
  Event 1 includes Event 2 & (\#1, Event 1, includes, Event 2) & (\#1, Event 2, includedBy, Event 1) \\
  \hline
  Event 2 includes Event 1 & (\#1, Event 1, includedBy, Event 2) & (\#3, Event 2, includes, Event 1) \\
  \hline
\end{tabularx}

\subsection{Exclusion}

\begin{tabularx}{\textwidth}{|*{3}{>{\raggedright\arraybackslash}X|}}
  \hline
  Relation & Event1 Log & Event2 Log \\
  \hline
  Event 1 excludes Event 2 & (\#1, Event 1, excludes, Event 2) & (\#1, Event 2, excludedBy, Event 1) \\
  \hline
  Event 2 excludes Event 1 & (\#1, Event 1, excludedBy, Event 2) & (\#3, Event 2, excludes, Event 1) \\
  \hline
\end{tabularx}

\subsection{Pending}
\begin{tabularx}{\textwidth}{|*{3}{>{\raggedright\arraybackslash}X|}}
  \hline
  Relation & Event1 Log & Event2 Log \\
  \hline
  Event 1 sets Pending Event 2 & (\#1, Event 1, setsPending, Event 2) & (\#1, Event 2, setPendingBy, Event 1) \\
  \hline
  Event 2 sets Pending Event 1 & (\#1, Event 1, setPendingBy, Event 2) & (\#3, Event 2, setsPending, Event 1) \\
  \hline
\end{tabularx}

\subsection{Conditions}
\begin{tabularx}{\textwidth}{|*{3}{>{\raggedright\arraybackslash}X|}}\hline
	Relation & Event1 Log & Event2 Log \\\hline
	Event 1 checks Event 2 which is executable & (\#1, Event 1, ConditionChecks true, Event 2) & (\#1, Event 2, ConditionChecked true, Event 1) \\\hline
	Event 1 checks Event 2 which is not executable & (\#1, Event 1, ConditionChecks false, Event 2) & (\#3, Event 2, ConditionChecked false, Event 1) \\\hline
	Event 2 checks Event 1 which is executable & (\#1, Event 1, ConditionChecked true, Event 2) & (\#1, Event 2, ConditionChecks true, Event 1) \\\hline
	Event 2 checks Event 1 which is not executable & (\#1, Event 1, ConditionChecked false, Event 2) & (\#3, Event 2, ConditionChecks false, Event 1) \\\hline
\end{tabularx}

\subsection{Execution}
\begin{tabularx}{\textwidth}{ | X | X | }
  \hline
  Relation & Event1 Log \\
  \hline
  Event 1 Execution begins & (\#1, Event 1, executionStart, ClientID) \\
  \hline
  Event 1 Execution fails & (\#2, Event 1, executionFail, ClientID) \\
  \hline
  Event 1 Execution success & (\#2, Event 1, executionSuccess, ClientID) \\
  \hline
\end{tabularx}

\subsection{Lock}
\begin{tabularx}{\textwidth}{|*{3}{>{\raggedright\arraybackslash}X|}}
  \hline
  Relation & Event1 Log & Event2 Log \\
  \hline
  Event 1 Locks Event 2 & (\#1, Event 1, lock, Event 2) & (\#1, Event 2, lockedBy, Event 1) \\
  \hline
  Event 2 Locks Event 1 & (\#1, Event 1, lockBy, Event 2) & (\#3, Event 2, lock, Event 1) \\
  \hline
\end{tabularx}

\subsection{Unlock}
\begin{tabularx}{\textwidth}{|*{3}{>{\raggedright\arraybackslash}X|}}
  \hline
  Relation & Event1 Log & Event2 Log \\
  \hline
  Event 1 Locks Event 2 & (\#1, Event 1, unlock, Event 2) & (\#1, Event 2, unlockedBy, Event 1) \\
  \hline
  Event 2 Locks Event 1 & (\#1, Event 1, unlockBy, Event 2) & (\#3, Event 2, unlock, Event 1) \\
  \hline
\end{tabularx}

\section{Happens Before Relations}

\begin{lstlisting}[breaklines=true]
    Y includedBy X       ->    X includes Y
    Y excludedBy X       ->    X excludes Y
    Y setPendingBy X     ->    X setsPending Y
    Y ConditionChecked X ->    X ConditionChecks Y
    Y LockedBy X         ->    X Lock Y
    Y UnlockedBy X       ->    X Unlock Y
    X Execution begins   ->    X Execution fails / Success
    X Execute Start      ->    X Locks Y
    X Locks Y            ->    X Include Y
    X Locks Y            ->    X Exclude Y
    X Locks Y            ->    X setPending Y
    X Locks Y            ->    X ConditionChecks Y
    X Locks Y            ->    X Unlock Y
    X Locks Y            ->    X Unlock Y     ->    X Execute Fail / Success
    Y Lockby X           ->    Y UnlockBy X   ->    Y LockBy "z"
\end{lstlisting}

\section{Malicious Nodes}
We must assume that the first contacted event is not malicious, since if it is and returns faulty information there is no way to discover and recover from this. The problem with malicious nodes has similar characteristics as that of the Byzantine generals problem, described by Lamport e.l. The history problem though has some differences, that must be worked around to apply the Byzantine generals algorithm to ensure consensus. The first difference is that in DCR-graphs a single event do not propose a value to get consensus about, but must gather values from each event in the graph since each event is the only one who is knows the value for it self. This however should not be a problem as a malicious event can only cheat in the following three ways:
\begin{definition}\label{malevent-type-omit}
	A malicious \texttt{event} can omit \texttt{logs} when asked for its \texttt{history}.
\end{definition}
\begin{definition}\label{malevent-type-add}
	A malicious \texttt{event} can add none-existent, consistent or inconsistent \texttt{logs} when asked for its \texttt{history}.
\end{definition}
\begin{definition}\label{malevent-type-responddifferent}
	A malicious \texttt{event} can send different \texttt{histories} to different requests.
\end{definition}


%Gammel argumentation
We need to argue that all DCR graphs can be built using a group of base structures. Each of these base structures have properties which can be used to describe the safety of the DCR graph history:

\begin{figure}[H]
	\centering
	\includegraphics[height=5cm]{figures/GraphStructure_OneToOne}
	\caption{With a maximum of one malicious event in this graph structure and it not being event $A$, we have no way of telling if $B$ lies or not.}
\end{figure}
\todo[inline]{Figur har underlige prikker på Event A.}

\begin{figure}[H]
	\centering
	\includegraphics[height=5cm]{figures/GraphStructure_OneToTwo}
	\caption{With a maximum of one malicious event in this graph structure and it not being event $A$, we are able to determine that someone lies but not who.}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[height=5cm]{figures/GraphStructure_OneToTwoChain}
	\caption{This graph is just an extension of that above and therefore proposes the same properties.}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[height=5cm]{figures/GraphStructure_OneToThree}
	\caption{With a maximum of one malicious event in this graph structure and it not being event $A$, we are able to determine that someone lies and who lies.}
\end{figure}

\newpar With these base structures it is possible to strengthen the requirements of the DCR graph to not only require that a maximum $M$ amount of malicious events exist is in a graph with $3M+1$ events (taken from the byzantine generals problem\todo{Source? - Fisk}). To use these rules, we must therefore have a maximum of 1 malicious events in each of these subgraphs.

\chapter{Algorithms}
The overall problem is: given a DCR graph with possible malicious nodes, for the events of the graph to reach consensus of a partial order of execution that has happened in that graph.

The algorithm consists of the following sub-algorithms executed in the following order:
\begin{itemize}
    \item Produce - gathers the history.
    \item Elect - checks if the majority of the workflow can accept the proposed history
    \item Simplify - takes the history and creates an order of execution.
\end{itemize}

\newpar Correctness should be based on:
\begin{itemize}
    \item How many events are corrupted.
    \item How well the algorithm can determine which events are corrupted.
    \item How well the algorithm can determine if any and how many events are corrupted.
\end{itemize}

%History is created by using Fetch-and-Stitch with validation in the stitching phase.

%The receiver of the first create history call should

%- create history ID
%- fetch history from neighbours
%    - each of these should:
%        - fetch
%        - stitch
%        - return
%- stitch
%- Call for a vote
%- Closure of event graph to an execution graph.
\include{content/datastructure}
\include{content/stitch}
\include{content/produce}
\include{content/elect}
\include{content/simplify}
