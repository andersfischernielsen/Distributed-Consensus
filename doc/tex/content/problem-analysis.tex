% !TeX root = ../DCR-Consensus.tex
% !TeX spellcheck = en_GB
\chapter{Domain Analysis}
\label{chap:domainanalysis}

\section{What is a History}
\begin{definition}
	An \textit{\textbf{Action}}\index{Action|(} contains the following information:
	\begin{itemize}
		\item The Id of the source Event, this is the Event that has logged the action.
		\item The time stamp of the action local to the source Event.
		\item The Id of the participating Event, this is the Event that are being contacted, or the Event who has initiated the action.
		\item The type of the Action, i.e. \texttt{IncludedBy}.
	\end{itemize}
	
	The reason that an Action is not called Event\index{Event}, is because this term is used for an Event in the DCR Graph workflow.
	\index{Action|)}
\end{definition}

\begin{definition}\label{definition:historya}
	A \textit{\textbf{History}}\index{History} is a set of Actions.\index{Action}
\end{definition}

\begin{lemma}\label{lemma:partialorder}
	A set is in partial order if the relation between elements in the set is reflexive, antisymmetric, and transitive.
	If S is a partially ordered set and every two elements of S are comparable, S is called a totally ordered or linearly ordered set, and the relation between elements in the set is a total or linear order.
	\todo[inline]{Source: Discrete Mathematics and its Applications, 7th ed. - Kenneth H. Rosen - Afsnit 9.6, Partial Orderings}
	
	Locally, a history is totally ordered, since the source Event knows the timestamps of all Actions. Therefore an Action can be compared to every other Action in the history, since the relation between timestamps of Actions is reflexive, antisymmetric\todo{Hvorfor er de antisymmetriske? - Fisk} and transitive. 
	If Action $A$ has timestamp $a$, Action $B$ has timestamp $b$ and Action $C$ has timestamp $c$, and $a < b$, $b < c$ then $a < c$. Therefore $A < C$.
	
	In a workflow these local histories are put together. This creates the possibility of having histories that cannot be totally ordered, because there haven't been exchanged messages between the source Events between the actions.\todo{Dette forstår jeg ikke. - Fisk} This means that it is not possible to decide between all pairs of actions, which action happened first.
	
	There is one limitation on the order of the actions that must be fulfilled by any history, locally or globally. That is, that the history cannot contain cycles as this would imply that two (or more) actions would have to happen before the other.
	
	\todo[inline]{Lav et argument, eller find nogle andre der har defineret at en total order også er en partial order. (I forhold til Wiki-definitionen ovenfor, er det er en partial order ikke har den 3. begrænsning, men at det ellers er det samme, og derfor er partial order en svagere definition af total order.)}
	
	This creates the need for a history of partial order.
\end{lemma}

\newpar Because of \autoref{lemma:partialorder} we can update \autoref{definition:historya} to the following definition:

\begin{definition}
	A \textit{\textbf{History}}\index{History} is a \textit{partially ordered} set of Actions.\index{Action}
	\label{definition:historyb}
\end{definition}

\section{Relations between logs}
\label{sec:relations}
All logs have the form (\#Number, FromID, RelationType, ToID/ByID)
\subsection{Inclusion}
\begin{tabularx}{\textwidth}{|*{3}{>{\raggedright\arraybackslash}X|}}
  \hline
  Relation & Event1 Log & Event2 Log \\
  \hline
  Event 1 includes Event 2 & (\#1, Event 1, includes, Event 2) & (\#1, Event 2, includedBy, Event 1) \\
  \hline
  Event 2 includes Event 1 & (\#1, Event 1, includedBy, Event 2) & (\#3, Event 2, includes, Event 1) \\
  \hline
\end{tabularx}

\subsection{Exclusion}

\begin{tabularx}{\textwidth}{|*{3}{>{\raggedright\arraybackslash}X|}}
  \hline
  Relation & Event1 Log & Event2 Log \\
  \hline
  Event 1 excludes Event 2 & (\#1, Event 1, excludes, Event 2) & (\#1, Event 2, excludedBy, Event 1) \\
  \hline
  Event 2 excludes Event 1 & (\#1, Event 1, excludedBy, Event 2) & (\#3, Event 2, excludes, Event 1) \\
  \hline
\end{tabularx}

\subsection{Pending}
\begin{tabularx}{\textwidth}{|*{3}{>{\raggedright\arraybackslash}X|}}
  \hline
  Relation & Event1 Log & Event2 Log \\
  \hline
  Event 1 sets Pending Event 2 & (\#1, Event 1, setsPending, Event 2) & (\#1, Event 2, setPendingBy, Event 1) \\
  \hline
  Event 2 sets Pending Event 1 & (\#1, Event 1, setPendingBy, Event 2) & (\#3, Event 2, setsPending, Event 1) \\
  \hline
\end{tabularx}

\subsection{Conditions}
\begin{tabularx}{\textwidth}{|*{3}{>{\raggedright\arraybackslash}X|}}\hline
	Relation & Event1 Log & Event2 Log \\\hline
	Event 1 checks Event 2 which is executable & (\#1, Event 1, ConditionChecks true, Event 2) & (\#1, Event 2, ConditionChecked true, Event 1) \\\hline
	Event 1 checks Event 2 which is not executable & (\#1, Event 1, ConditionChecks false, Event 2) & (\#3, Event 2, ConditionChecked false, Event 1) \\\hline
	Event 2 checks Event 1 which is executable & (\#1, Event 1, ConditionChecked true, Event 2) & (\#1, Event 2, ConditionChecks true, Event 1) \\\hline
	Event 2 checks Event 1 which is not executable & (\#1, Event 1, ConditionChecked false, Event 2) & (\#3, Event 2, ConditionChecks false, Event 1) \\\hline
\end{tabularx}

\subsection{Execution}
\begin{tabularx}{\textwidth}{ | X | X | }
  \hline
  Relation & Event1 Log \\
  \hline
  Event 1 Execution begins & (\#1, Event 1, executionStart, ClientID) \\
  \hline
  Event 1 Execution fails & (\#2, Event 1, executionFail, ClientID) \\
  \hline
  Event 1 Execution success & (\#2, Event 1, executionSuccess, ClientID) \\
  \hline
\end{tabularx}

\subsection{Lock}
\begin{tabularx}{\textwidth}{|*{3}{>{\raggedright\arraybackslash}X|}}
  \hline
  Relation & Event1 Log & Event2 Log \\
  \hline
  Event 1 Locks Event 2 & (\#1, Event 1, lock, Event 2) & (\#1, Event 2, lockedBy, Event 1) \\
  \hline
  Event 2 Locks Event 1 & (\#1, Event 1, lockBy, Event 2) & (\#3, Event 2, lock, Event 1) \\
  \hline
\end{tabularx}

\subsection{Unlock}
\begin{tabularx}{\textwidth}{|*{3}{>{\raggedright\arraybackslash}X|}}
  \hline
  Relation & Event1 Log & Event2 Log \\
  \hline
  Event 1 Locks Event 2 & (\#1, Event 1, unlock, Event 2) & (\#1, Event 2, unlockedBy, Event 1) \\
  \hline
  Event 2 Locks Event 1 & (\#1, Event 1, unlockBy, Event 2) & (\#3, Event 2, unlock, Event 1) \\
  \hline
\end{tabularx}

\section{Happens Before Relations}

\begin{lstlisting}[breaklines=true]
    Y includedBy X       ->    X includes Y
    Y excludedBy X       ->    X excludes Y
    Y setPendingBy X     ->    X setsPending Y
    Y ConditionChecked X ->    X ConditionChecks Y
    Y LockedBy X         ->    X Lock Y
    Y UnlockedBy X       ->    X Unlock Y
    X Execution begins   ->    X Execution fails / Success
    X Execute Start      ->    X Locks Y
    X Locks Y            ->    X Include Y
    X Locks Y            ->    X Exclude Y
    X Locks Y            ->    X setPending Y
    X Locks Y            ->    X ConditionChecks Y
    X Locks Y            ->    X Unlock Y
    X Locks Y            ->    X Unlock Y     ->    X Execute Fail / Success
    Y Lockby X           ->    Y UnlockBy X   ->    Y LockBy "z"
\end{lstlisting}

\section{Malicious Nodes}
We must assume that the first contacted event is not malicious, if otherwise it could return faulty information and we would have no way to check up on that.
We need to argue that all DCR graphs can be built using a group of base structures. Each of these base structures have properties which can be used to describe the safety of the DCR graph history.

\begin{figure}
	\centering
	\includegraphics{figures/GraphStructure_OneToOne}
\end{figure}
With a maximum of one malicious event in this graph structure and it not being event A, we have no way of telling if B lies or not.

\begin{figure}
	\centering
	\includegraphics{figures/GraphStructure_OneToTwo}
\end{figure}
With a maximum of one malicious event in this graph structure and it not being event A, we are able to determine that someone lies but not who.

\begin{figure}
	\centering
	\includegraphics{figures/GraphStructure_OneToTwoChain}
\end{figure}
This graph is just an extension of that above and therefore proposes the same properties.

\begin{figure}
	\centering
	\includegraphics{figures/GraphStructure_OneToThree}
\end{figure}
With a maximum of one malicious event in this graph structure and it not being event A, we are able to determine that someone lies and who lies.


This way we can strengthen the requirements of the DCR graph to not only require that a maximum M amount of malicious events exist is in a graph with 3M+1 events (taken from the byzantine generals problem). That to use these rules, we must have that maximum of 1 malicious event exist in each of these subgraphs.

\chapter{Algorithms}
The overall problem is: given a DCR graph with possible malicious nodes, for the events of the graph to reach consensus of a partial order of execution that has happened in that graph.

The algorithm consists of the following subalgorithms executed in that order:
\begin{itemize}
    \item Produce - which gathers the history.
    \item Elect - which checks if the majority of the workflow can accept the proposed history
    \item Simplify - which takes the history and creates an execution only history.
\end{itemize}

Correcness should be based on:
\begin{itemize}
    \item How many events can be corrupted.
    \item How well the algorithm can determine which events are corrupted.
    \item how well the algorithm can determine if any and how many events are corrupted.
\end{itemize}

%History is created by using Fetch-and-Stitch with validation in the stitching phase.

%The receiver of the first create history call should

%- create history ID
%- fetch history from neighbours
%    - each of these should:
%        - fetch
%        - stitch
%        - return
%- stitch
%- Call for a vote
%- Closure of event graph to an execution graph.
\include{content/datastructure}
\include{content/stitch}
\include{content/produce}
\include{content/elect}
\include{content/simplify}
